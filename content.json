[{"title":"关于时区的总结","date":"2017-12-29T08:06:00.998Z","path":"2017/12/29/关于时区的一些总结/","text":"最近写一个手机营销页面, 因为本身交互并不是很复杂, 故采用原生JS书写, 不使用任何框架。项目本身有对时间进行处理的需求, 但出于性能以及移动端上流量的考虑, 没有引入moment之类的时间库(moment.min.js gzip后也有12.4KB, 本身整个小项目才不超过30KB), 用原生的Date来解决时间、时区上的转换, 但是在这个过程中, 遇到了一些坑, 这里便把时区以及其相关的知识, 和我在这个项目中踩过的坑总结一下~ 时区是什么呢? 根据百科上的解释, 在1884年的时候, 人们为了克服时间上的混乱, 在华盛顿召开了一次国际经度会议，会中规定将全球划分为24个时区（东、西各12个时区）。并规定英国（格林尼治天文台旧址）为中时区（零时区）、东1-12区，西1-12区。每个时区横跨经度15度，时间正好是1小时。最后的东、西第12区各跨经度7.5度，以东、西经180度为界。每个时区的中央经线上的时间就是这个时区内统一采用的时间，称为区时，相邻两个时区的时间相差1小时。我们国家地域辽阔, 横跨5个地理时区。但统一根据北京时间划分, 列为东八区。 以上是关于时区的基本概念, 我们知道, 在JavaScript中, 当我们实例化Date构造函数并调用其toString方法, 会返回当前的本地时间字符串12// Mon Jan 15 2018 20:32:15 GMT+0800 (中国标准时间)(new Date()).toString() 这其中GMT+0800, 便代表的是相对于GMT(零时区, 后文有更详细的解释)时间的偏移量, +0800表示本地时间比GMT时间快八小时, 则本地时间Mon Jan 15 2018 20:32:15 GMT+0800对应的GMT时间为Mon Jan 15 2018 12:32:15 GMT+0000, 当然, GMT后面的+0000一般会省略。 在JavaScript的Date对象实例上, 我们还可以看到与之相关的除了toGMTString, 还有toUTCString之类的方法。那其中的GMT与UTC具体是什么意思, 又有什么区别呢？ GMT代表的是Greenwich Mean Time, 即格林尼治时间, 又称为世界时(这里表达’世界时’是不准确的, 其有一定的误差), 中时区(零时区), 是指英国格林尼治所在地的标准时间。也是表示地球自转速率的一种形式。以地球自转为基础的时间计量系统。地球自转的角度可用地方子午线相对于地球上的基本参考点的运动来度量。这段介绍组合自各大百科，后面的内容有点小复杂，还需要有点地理基础，其实这里我只需要理解GMT是我们时区中的零时区, 其也指向我们理想的世界时, 但实际与世界时之间有一定误差。 UTC代表的是Coordinated Universal Time, 即协调世界时，世界标准时间。协调世界时是以原子时秒长为基础，在时刻上尽量接近于世界时的一种时间计量系统, 其误差必须精确到0.9秒以内, 可以说是GMT更精准的一种表现。 GMT和UTC所期望指向的都是我们理想的世界时，然而实际上皆有误差, 但是UTC比GMT要更精确, 所以在JS中, 如果有需求, 相较于GMT方法(实际上已从Web标准中删除), 更推荐使用Date实例上UTC方法。 有时候, 我们需要在服务器端保存我们的数据, 因为客户端的时区不尽相同，我们一般会在服务器端上将时间保存为UTC时间，然后客户端渲染的时候通过转换，将数据渲染为客户端时区的时间，在客户端保存时间，用户进行上传操作的时候，再转换为UTC时间保存。往往,只需要前后端通过时间戳的形式来传递时间就能很好的解决这个需求, 但是有时候可能后端有特殊原因，传来的是一个Date字符串, 这时候就需要自己去解析字符串了。在这个项目中, 后端给我传来的Date字符串类似于这样2017-12-27T06:59:25.000+0000, 当时我的想法是直接把其作为参数传入Date构造函数, 去实例化一个Date对象, 然后通过getFullYear等一系列方法去获取具体的年月日时分秒, 去组合自己想要的格式字符串, 可是在第一步就遇到了问题, chrome中可以正确解析的字符串格式, 在其他浏览器会直接返回invalid date。这是什么原因呢? 翻阅ecma规范后发现, 在规范中Date构造函数接收的参数只有如下三种形式(可见规范): Date ( year, month [ , date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] ) Date ( value ) Date () 其中并不包括字符串形式的参数, 所有浏览器对Date字符串的支持都是自身私有的实现, 所以每个浏览器才有各自不同的表现(于各大浏览器对不同格式的Date字符串的支持, 具体可见链接)。 知道了问题所在, 那么解决办法也就出来了, 不再将字符串作为参数传给Date构造函数, 而是以ecma规范中的第一种传参形式(Date(year,month[,date[,hours[,minutes[,seconds[,ms]]]]]))调用。 第一步, 先解析后端传来的Date字符串1234// 获取我们所需的年,月,日,分,时,秒,毫秒, 并转为数字类型const utcTimeArr = time.match(/(\\d+)(?!\\d)/g).map(v =&gt; parseInt(v))// 月份比较特殊, 在对Date实例对象set或get月份时候, 0代表1月份, 1代表2月份, 以此类推, 故这里需减1utcTimeArr[1]-- 现在我们得到了由年,月,日,分,时,秒,毫秒组成的一个数组, 接下来直接将其作为参数传给Date构造函数去获取Date实例么？不可以忘记一开始我们后端传来的可是UTC时间, 如果我们直接传入的话是会被解析为本地时区的时间的, 与后端的时间就会产生偏差, 所以这里我们第二步还需要做一点处理1234567// 获取本地时区与UTC时间之间的偏移的总秒数时间// 需要注意的是这里的偏移时间返回的是 UTC - 本地时区的分钟数// 以东八区为例, 东八区比零时区快8小时, 这里返回的就是-8 * 60 = -480const offsetSecond = (new Date()).getTimezoneOffset() * 60 * 1000// 先获取偏移后的时间戳, 减去偏移量就获得了偏移前的时间戳// 再以这个时间戳作为参数, 实例化Date对象const date = new Date((new Date(...utcTimeArr)) - offsetSecond) 拿到我们正确时间的Date对象后, 就可以直接通过对象上的各种getter方法去组成我们所需要的各种格式的本地时间字符串了1234567const year = date.getFullYear()const month = leftPadding(date.getMonth() + 1, 2, '0')const day = leftPadding(date.getDate(), 2, '0')const hour = leftPadding(date.getHours(), 2, '0')const minute = leftPadding(date.getMinutes(), 2, '0')const second = leftPadding(date.getUTCSeconds(), 2, '0')const localStr = `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;T$&#123;hour&#125;:$&#123;minute&#125;:$&#123;second&#125;` 将本地字符串格式保存为UTC字符串传会后端也是类似的方法。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yuyanggong.github.io/tags/JavaScript/"},{"name":"timezone","slug":"timezone","permalink":"https://yuyanggong.github.io/tags/timezone/"},{"name":"Date","slug":"Date","permalink":"https://yuyanggong.github.io/tags/Date/"}]},{"title":"node爬虫初体验——根据植物种名爬取其详细信息","date":"2017-10-15T02:16:20.684Z","path":"2017/10/15/node爬虫初体验/","text":"实践周的时候，老师布置实习作业，要求查清全校的树种类型，并要完善的写下其界门纲目科属种的信息。在实地调查的过程中，各类树种的种名我们都已获取，剩下的就是上网搜索其详细信息并记录下来了，这一步很繁琐，我觉得完全可以通过写脚本来自动化处理，而其中关键在于爬虫爬取植物的详细信息。 然后，开干吧~ 爬取网站的选取本来一开始想选取百度百科爬取内容的，但是百度百科的植物URL比较特殊。比如栀子花的百度百科URL为http://baike.baidu.com/item/栀子花/77102(其中’栀子花’为非法URI字符,需要encodeURI一下才合法,这里为表示清晰就直接这样显示了)。其后跟着一个77102数字ID, 为的是区分同名词条，然而，在写爬虫的时候，这个数字ID我们无法获取，所以不能正确获取URL,故放弃百度百科。那我们爬取哪个百科网站呢？视线转向互动百度，其栀子花的百科URL为http://www.baike.com/wiki/栀子花, 观察发现其URL的格式为http://www.baike.com/wiki/${植物名称}, 可以用作爬取网站(当然后面发现有这个其实也有同名词条的坑，不过可以判断解决)。 获取植物的名称我们将所需爬取的植物种名，放在主目录的input.txt文件内，并在每两种名间用回车符(unix系统下为’\\n’, mac系统下为’\\r’, windows系统下为’\\r\\n’)隔开。其内容格式如下： 123456789101112&lt;input.txt&gt;香樟广玉兰雪松棕榈柚子树罗汉松泡桐杜英马尾松............ 在爬虫开始工作前，先读取所需爬取的数据，代码如下：123// 因为必须获取输入的植物种名才能开始爬取数据，故这里使用readFile的同步方法// 并将其得到的内容以回车为界限分割成数组let inputArr = fs.readFileSync('./input.txt', 'utf-8').split(/\\r\\n|\\r|\\n/); 根据已知植物种名获取其详细信息前面我们获取了已知的植物种名，接下来要根据已知种名来获取其详细信息了，换言之，要开始写爬虫了。 首先，我们需要安装cheerio库，帮助我们解析爬取到的html页面。其暴露的接口与JQuery类似，具体可见其cherrio npm下安装1npm install cheerio --save yarn下安装1yarn add cheerio 安装完cherrio后就可以开始写爬虫脚本了。 先require所需的node模块123let http = require('http'), fs = require('fs'), cheerio = require('cheerio'); 然后，根据之前获取到的植物种名，去爬取详细数据。一开始本来想利用node异步的特点去同时发起get请求的，但是因为网络原因(同一源的并发请求过多可能被目标网站认定为DDOS,而拒绝访问)。所以这里我们使用逐个发送get请求，上一条植物数据get请求成功后，然后再发送下一条get请求。核心代码如下：12345678910111213141516171819202122232425let count = 0;function getPlantInfo(i) &#123; count = i + 1; // 输入数组的数据全部解析完毕后执行收尾函数，并跳出此递归 if(i &gt;= inputArr.length) &#123; endPlantFile(); return; &#125; let plantName = inputArr[i]; new Promise((resolve, reject) =&gt; &#123; // getUrlContent函数，接受植物种名、通用url和一个回调函数， // 利用http.get获取所需爬取的网站的内容 getHtml(plantName, 'http://www.baike.com/wiki/', (err, content) =&gt; &#123; if(err) console.log(err); resolve(content) &#125;) // getInfo函数解析返回的html网页，提取我们需要的内容 &#125;).then(res =&gt; getInfo(res)) // appendPlantFile将返回的内容添加进文件中 .then(res =&gt; appendPlantFile(`./res/$&#123;outputFlie&#125;.json`, res)) .then(() =&gt; console.log(`$&#123;plantName&#125; 保存完毕`)) // 递归继续get后续的植物详细信息 .then(v =&gt; getPlantInfo(i + 1)) .catch(e =&gt; console.log(e.message));&#125; 上面为大致结构。其中我们先通过getHtml获取目标植物页面的html，其实现如下12345678910111213141516171819202122// 获取相关植物url返回的html网页function getHtml(name, url, callback) &#123; // 植物名需要编码一下 url += encodeURI(name); // 发送请求 http.get(url, (res) =&gt; &#123; const &#123; statusCode &#125; = res; // 当请求失败时, 打印失败信息, 并将失败的植物名保存 if(statusCode !== 200) &#123; console.log(`http.get for $&#123;name&#125;`) console.log(`fail. status code is $&#123;statusCode&#125;`); appendPlantFile('./res/error.json', name+'\\n') return; &#125; // 将拿到的html内容传给callback let contentArr = []; res.on('data', (res) =&gt; contentArr.push(res)); res.on('end', () =&gt; &#123; callback(null, [contentArr.join(''), url]); &#125;); &#125;).on('error', (e) =&gt; console.log(e.message));&#125; 拿到html内容以后, 我们借助cherrio这个库对其进行解析，并获取其中我们需要的信息。1234567891011121314151617181920212223242526272829303132333435363738394041// 解析html网页，并从中筛选我们需要的信息function getInfo(resArr) &#123; let $ = cheerio.load(resArr[0]), url = resArr[1], resObj = &#123;&#125;, name = $('h1').text(); // 防止同名词条干扰 if(/\\[/.test(name)) &#123; // 如果是非植物的同名词条，则将其推入inputArr数组 // 待后续重新加载词条 if(!(/植物|花|新鲜|水果|木/.test(name))) &#123; inputArr.push(name.replace(/\\[.*?\\]/, '[植物]')); getPlantInfo(inputArr.indexOf(name.replace(/\\[.*?\\]/, '')) + 1); throw new Error(`$&#123;name&#125; 为同名词条，需重新加载`) &#125; &#125; $('#datamodule table td').each((i, elem) =&gt; &#123; let text = $(elem).text(); if(/\\S/.test(text)) &#123; let keyAndValue = text.split('：') .map(v =&gt; v.replace(/\\s|\\n/g, '')); resObj[keyAndValue[0]] = normalizeStr(keyAndValue[1]); &#125; &#125;); resObj['形态特征'] = ($('p').text().match(/[\\u4e00-\\u9fa5]*(乔木|灌木|草本|藤本)[\\u4e00-\\u9fa5]*/)||[])[0]; resObj.link = url; // 有的植物显示的别名，有的是中文别名，这里我们统一用别名 resObj['别名'] = resObj['中文别名']; // 统一分布区域都为分布 resObj['分布'] = ['分布', '分布区域', '主要区域'] .map(v =&gt; resObj[v]) .filter(v =&gt; v)[0]; return JSON.stringify(resObj);&#125; 然后将我们获取到的结果对象字符串添加进指定的json文件中, 其实现也很简单。123function appendPlantFile(file, res) &#123; fs.appendFileSync(file, res+'\\n');&#125; 接下来, 递归调用1getPlantInfo(i + 1) 当获取了所有的数据后，我们根据最终的json文件，去生成excel表格，这里我们用到了json2xls这个库来转换。1234567891011function endPlantFile() &#123; let content = fs.readFileSync(`./res/$&#123;outputFlie&#125;.json`, 'utf-8').split(/\\n/).slice(0, -1), json = `[$&#123;content.join(',\\n')&#125;]`, xls = json2xls(JSON.parse(json), &#123; fields: ['中文学名', ...'界门纲目科属种'.split(''), '别名', '分布', '形态特征', 'link'] &#125;); fs.writeFileSync(`./res/$&#123;outputFlie&#125;.json`, json); fs.writeFileSync(`./res/$&#123;outputFlie&#125;.xlsx`, xls, 'binary'); console.log(`全部植物解析完毕`)&#125; 最终，得到了包含所有界门纲目科属种信息的植物excel表格了，任务完成~","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yuyanggong.github.io/tags/JavaScript/"},{"name":"node","slug":"node","permalink":"https://yuyanggong.github.io/tags/node/"},{"name":"爬虫","slug":"爬虫","permalink":"https://yuyanggong.github.io/tags/爬虫/"}]},{"title":"【JavaScript】this全解析","date":"2017-09-29T16:09:40.676Z","path":"2017/09/30/【JavaScript】this全解析/","text":"在JavaScript中，this的指向一直是一个很令人头疼的问题，但是如果找到了诀窍，要搞清this, 其实并不会很难。 与变量求值时候的词法作用域不同， this求值时候，是采用的动态作用域，总结起来很简单，即this指向其调用者。 具体地，this的调用可以分为下面五种情况，我们将从这五种情况来讨论 普通函数 方法函数 构造函数/class函数及其super 通过bind、call、apply绑定this的函数 箭头函数 普通函数作为普通函数调用时，其this指向全局window1234567function outer()&#123; function inner()&#123; console.log(this); &#125; inner(); // 内部this指向window&#125;outer(); 根据我们之前所说的this指向其调用者, 经分析可知这里 其执行环境不在window下 其调用者也不是window(非全局环境下作为默认函数调用是没有调用者的)。然而this却指向window, 这是不合理的。JavaScript是一门在不断进化的语言，一开始的设计存在着诸多不合理的地方，除了题主所问的函数调用时this的指向问题，还有诸如重复声明，以及未声明便可以初始化的问题。为了消除Javascript语法的一些不合理、不严谨、不安全之处，减少一些怪异行为等目的，ECMAscript 5添加了第二种运行模式： 严格模式。在严格模式下，此处this会合理的指向，console.log打印出来的将是undefined(因为没有调用者)。123456'use strict'function test() &#123; // 指向undefined console.log(this)&#125;test() 方法函数作为方法函数调用时，则是之前一直说的this指向其调用者。1234567var obj = &#123; test: function () &#123; console.log(this) &#125;&#125;// 调用者为obj, 故指向objobj.test() 同样123456789var outerObj = &#123; innerObj: &#123; fn: function () &#123; console.log(this) &#125; &#125;&#125;// this指向outerObj.innerObjouterObj.innerObj.fn() 当然, 需要注意的是, 这里的调用者是指执行时的直接调用者, 而不是声明时的储存位置。12345678910var obj1 = &#123; test: function () &#123; console.log(this) &#125;&#125;const obj2 = &#123;&#125;// 将obj1的test方法引用给obj2的fnobj2.fn = obj1.test// 调用者为obj2, 故指向obj2obj2.fn() 当然, 有这种情况123456789var obj = &#123; fn: function () &#123; console.log(this) &#125;&#125;// this指向objobj.fn()// this指向全局window(0, obj.fn)() 为什么会发生这种this丢失的现象呢, 其实(0, obj.fn)这个表达式的返回值即obj.fn指向的【源函数】, 实际上进行的是普通函数调用, 而不是方法调用。在babel中, 也能常见到这种用法。 构造函数/class函数及其superJavaScript中, 当使用new关键字对一个函数进行实例化时, 其函数会作为构造函数调用, 此时, 构造函数内部的this指向一个隐式创建的空对象, 最终若没有显式的返回对象的话, 则会默认返回这个隐式创建的对象。new的过程大致可以分为下面四个步骤: 隐式创建一个内部的空对象 将内部对象的原型与构造函数的原型链连接 执行构造函数内部代码, 此时this执行内部对象 若没有显式的返回对象时, 返回我们的内部对象。(若有显式的返回对象时, 则按普通函数返回)我们可以用JavaScript大致模拟一下其过程。123456function mockNewProcess (constructor, arg) &#123; var obj = &#123;&#125; obj.__prototype__ = constructor.prototype constructor.apply(obj, arg) return obj&#125; 而class属于es6的新特性, 属于语法糖, 与ES5中的构造函数没有本质上的区别, 其constructor及其中super的this指向依旧是我们的内部对象。 通过bind、call、apply绑定this的函数我们也可以通过bind、call、apply来改变其this的指向。这是挂载在函数对象原型链上的三种方法(Function.prototype.bind, Function.prototype.call, Function.prototype.apply)。其中call, apply改变函数调用时的this指向12345678910var obj1 = &#123; fn: function () &#123; console.log(this) &#125;&#125;var obj2 = &#123;&#125;// this指向obj2obj1.fn.call(obj2)// this指向obj2obj1.fn.apply(obj2) 当然, apply与call的区别也很明显。 1. 其接受的参数不同apply与call接收的第一个参数都是指定this指向的对象，而后面的参数, apply会以数组的形式作为原函数的参数调用, call会以普通参数的形式作为原函数的参数调用, 举个栗子：123456789101112131415161718192021var originObj = &#123; add: function (a, b, c) &#123; return this.number + a + b + c &#125;&#125;var applyObj = &#123; number: 1&#125;var callObj = &#123; number: 1&#125;// 函数通过apply更改this指向时的调用时, 其原本所需要接收的参数, // 在apply中需要通过数组的形式, 作为第二个参数传入// return 7originObj.add.apply(applyObj, [1, 2, 3])// 函数通过call更改this指向时的调用时, 其原本所需要接收的参数, // 在call中需要通过普通额外的参数的形式, 作为第二个参数及其之后的参数传入// return 7originObj.add.call(callObj, 1, 2, 3) 2. 其性能不同call的性能较apply要更好, 速度更快。一些框架或工具库为了追求极限的性能, 会尽可能的使用call代替apply, 比如工具库underscore。1234567891011121314151617181920var optimizeCb = function(func, context, argCount) &#123; if (context === void 0) return func; switch (argCount) &#123; case 1: return function(value) &#123; return func.call(context, value); &#125;; // The 2-parameter case has been omitted only because no current consumers // made use of it. case null: case 3: return function(value, index, collection) &#123; return func.call(context, value, index, collection); &#125;; case 4: return function(accumulator, value, index, collection) &#123; return func.call(context, accumulator, value, index, collection); &#125;; &#125; return function() &#123; return func.apply(context, arguments); &#125;; &#125;; 这是underscore的一段代码, 就使用call替换apply来写优化后的回调函数。但是在各大新版本浏览器中, apply的性能已经被优化, 与call没有性能上的差别, 知乎上有个很不错的回答。 bind则与apply和call不太一样, 其接受唯一一个参数作为this的指向, 然后返回一个绑定了this的函数, 返回的函数除了this绑定了以外, 内部逻辑与原函数完全相同; bind方法没有副作用, 不会修改原函数。举个例子1234567function test () &#123; return this.name &#125;var testObj = &#123; name: 'test'&#125;var bindedFn = test.bind(testObj)// 'test'bindedFn() 箭头函数ES6中引入了箭头函数的语法, 通过这种方式, 我们可以简单将函数的this指向绑定为外部函数的this, 举个例子1234567891011121314151617var obj = &#123; count: 1, changeCount: function (v) &#123; const arrowFn = () =&gt; &#123; this.count = 2 &#125; // 这里是作为普通函数调用, 其this理应指向window(非严格模式)或undefined(严格模式) // 但是因为其声明时候属于箭头函数, 其this指向外部函数的this // 即指向changeCount的this, 根据changeCount的调用方式而定 arrowFn() &#125;&#125;// 此处changeCount的调用方式是方法调用, this指向调用者obj// 故其内部的arrowFn函数的this也指向objobj.changeCount()// 2console.log(obj.count) 其实, 我们可以将箭头函数理解成, 其内部没有this, 需要从外部查询this, 换言之, 其this的求值从动态作用域转换成了词法作用域, 不再是根据其直接的调用者而定, 而是指向其外部函数的调用者。上述示例代码相当于:12345678910111213141516var obj = &#123; count: 1, changeCount: function (v) &#123; // 保存changeCount函数的this引用 var that = this function arrowFn () &#123; // 修改that, 即外部this的count属性 that.count = 2 &#125; arrowFn() &#125;&#125;// 此处changeCount的调用方式是方法调用, this指向调用者objobj.changeCount()// 2console.log(obj.count) 所以对箭头函数使用apply, call, bind方法, 或改变其调形式为方法调用或函数调用, 都无法改变箭头函数其内部this的指向。1234567891011121314151617181920212223242526272829var originObj = &#123; number: 1, getArrowFn: function () &#123; // 返回一个箭头函数, 此箭头函数调用时会返回this.number return () =&gt; this.number &#125;&#125;var obj = &#123; number: 2&#125;// 在这一步, 箭头函数arrowFn内部this的指向已经确定了// 指向其外部函数getArrowFn的调用者, 即originObjconst arrowFn = originObj.getArrowFn()// 通过call、apply、bind无法改变箭头函数的this// 1arrowFn.call(obj)// 1arrowFn.apply(obj)// 1arrowFn.bind(obj)()// 通过函数调用或方法调用也无法改变箭头函数的this// 1arrowFn()obj.fn = arrowFn// 1obj.fn() 那通过new, 来将箭头函数当做一个构造函数进行实例化呢?结果会报错, 规范规定箭头函数是无法实例化的。123const arrowFn = () =&gt; this// Uncaught TypeError: arrowFn is not a constructornew arrowFn() end","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yuyanggong.github.io/tags/JavaScript/"}]},{"title":"如何书写Vue组件的单元测试","date":"2017-09-27T15:00:32.220Z","path":"2017/09/27/如何书写Vue组件的单元测试/","text":"前阵子使用karma配合jasmine给Vue组件写单元测试，有一点小小的心得，总结在这里，大致内容分为依赖注入和具体测试代码的书写俩部分。 一、依赖注入首先通过require拿到我们的组件注入器， 并对代码进行依赖注入， 得到依赖注入后的组件。(1)拿到组件注入器12// 以TagList举例const listInject = require('!!vue?inject!components/followers/TagList') 这里在require中使用webpack的管道语法，以vue-loader和inject-loader加载我们的组件，得到注入器。(2)使用1中的组件注入器对组件进行依赖注入12345678910111213141516171819202122232425// 给注入器函数传入一个对象， 对象的key为注入的路径， value为被注入的内容。// 注入器函数的返回值是其被依赖注入的原组件const listComp = listInject(&#123; // 对当前组件依赖的组件进行注入， // 推荐使用空组件模拟注入内容, 这样无需考虑子组件的逻辑 '../Icon.vue': createEmptyCop('Icon'), // 对当前组件引入的API进行注入 '../../api/tag': &#123; // 模拟当前组件中用到的相应API getTag () &#123; ... &#125; &#125;, // 对当前组件引用公共方法的注入 'lib/escape': &#123; // 模拟当前组件中用到的公共方法 escape () &#123; ... &#125; &#125;, // 对当前组件中引用的Vue插件方法进行注入, 如Vuex中的mapActions 'Vuex': &#123; mapActions () &#123; ... &#125; &#125;&#125;) 当我们对组件进行依赖注入时候，我们只需要关心当前组件的功能及UI是否正常，而不应过多关注依赖。可以将其外部引用的依赖全部模拟注入。其依赖的类型大致有四种 组件组件的注入比较简单， michael在unit/util库中新增了一个方法createEmptyComp，我们利用其创建空组件，进行注入。此方法接受一个唯一参数字符串，表示组件名，返回一个空组件。 1'../Icon.vue': createEmptyCop('Icon') API服务API服务的注入， 需要依据当前组件的逻辑来进行相关注入， 但是大多数情况下，使用到API服务的地方，都是给其传入一个回调函数， 我们可以通过内部书写逻辑拿到此回调函数， 后续对其进行测试，如： 12345678910let getTagCbconst listComp = listInject(&#123; '../../api/tag': &#123; // 模拟当前组件中用到的相应API getTag (cb) &#123; // 将回调函数保存在getTagCb中，后续对getTagCb进行测试 getTagCb = cb &#125; &#125;&#125;) 公共函数公共函数较为简单，大多数情况模拟公共函数注入可以直接返回参数， 如 123456789const listComp = listInject(&#123; '../../api/tag': &#123; // 模拟当前组件中用到的公共函数 // 直接将input返回 escape (input) &#123; return input &#125; &#125;&#125;) 也有小部分公共函数逻辑较为复杂，特殊情况，特殊处理 Vue插件方法插件方法，我们只需要判断是否传入了我们所期望的实际参数， 并以此断言。一般插件方法如mapActions，大多数情况只会用到一次， 我们可以像API服务一样去保存传入的参数，在后续断言即可，如：12345678910111213141516171819let mapActionsArgsconst listComp = listInject(&#123; 'vuex': &#123; // 模拟当前组件中用到的Vue插件方法 mapActions (...arg) &#123; mapActionsArgs = arg &#125; &#125;&#125;)...// 后续进行断言判断describe('mapActions', () =&gt; &#123; it('should correct map actions', () =&gt; &#123; const Comp = Vue.extend(listComp) // 不需要挂载， 在实例化时候，Vue就会执行事件的绑定 const vm = new Comp() expect(mapActions).toEqual([...你期望传入的参数...]) &#125;)&#125;) 二、具体测试代码的书写当我们给Vue组件书写单元测试的时候，需要从以下俩部分测试。 功能测试 UI测试 功能测试在功能测试中， 我们需要测试的内容大致包括： props测试props是否正确传入，如： 12const vm = createTest(aliasComp, &#123; isUnfollowed: true &#125;)expect(vm.isUnfollowed).toBe(true) filters测试filters是否满足预期功能, 我们可以通过vm.$options.filters.xxx拿到filters的源函数(同样可以通过Comp.filters.xxx去拿)， 如： 1234const Comp = Vue.extend(listComp)const vm = new Comp()const myFilters = vm.$options.filters.myFiltersexpect(myFilters(input)).toBe(/* 预期的返回值 */) watch测试watch监听相关数据的逻辑是否正确, 通过vm.$options.watch.xxx拿到watch的源函数， 如： 12345678910const Comp = Vue.extend(listComp)const vm = new Comp()const yourWatchData = vm.$options.filters.yourWatchDataconst obj = &#123; /* 作为我们yourWatchData的调用对象，需要进行数据模拟 */ &#125;// 绑定调用对象， 并传入测试参数yourWatchData.call(obj, /* your arguments */)// 断言调用对象上的属性是否按照我们的预期进行了更新expect(obj).toEqual(&#123; /* 我们预期的更新后的对象 */&#125;) computed测试计算属性是否正确返回我们预期的内容，通过vm.$options.computed.xxx拿到computed的源函数， 测试方法类似filters methods测试methods是否如我们预期执行，通过vm.$options.methods.xxx拿到methods的源函数， 如果有返回值，测试各种不同Input的情况下，返回值是否都如我们预期， 测试方式如computed；如果有副作用，比如对this进行了更改，则利用call来改变调用对象，再断言调用对象是否正确更新，测试方式如watch 生命周期钩子我们同样可以在vm.$options上拿到我们的生命周期钩子函数，不过其表现形式是一个数组， 而我们需要测试的当前组件的生命钩子是数组的最后一个元素， 具体测试方法如下： 123456789101112const Comp = Vue.extend(listComp)const vm = new Comp()// 这里以created举例const createdArr = vm.$options.createdconst created = createdArr[createdArr.length - 1]const obj = &#123; /* 作为我们created的调用对象，需要进行数据模拟 */ &#125;// 绑定调用对象created.call(obj)// 断言调用对象上的属性是否按照我们的预期进行了更新expect(obj).toEqual(&#123; /* 我们预期的更新后的对象 */&#125;) UI测试测试我们UI元素(DOM节点)是否正常渲染。在UI测试中，vue实例是需要挂载在已存在的DOM节点上其，而在vue实例挂载过程中，会编译模板并进行渲染的，所以在UI测试中我们需要模拟一整套完整的数据，关于UI测试，具体内容可以参考饿了么的测试案例https://github.com/ElemeFE/element","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yuyanggong.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://yuyanggong.github.io/tags/Vue/"},{"name":"单元测试","slug":"单元测试","permalink":"https://yuyanggong.github.io/tags/单元测试/"}]},{"title":"贝格尔编排法","date":"2017-09-12T13:51:55.635Z","path":"2017/09/12/贝格尔编排法/","text":"贝格尔编排法从1985年起，世界性排球比赛多采用“贝格尔”编排法。其优点是单数队参加时可避免第二轮的轮空队从第四轮起每场都与前一轮的轮空队比赛的不合理现象。 编排步骤一、将参赛队伍按顺序分为俩部分，前一半和后一半各为一部分，若参赛队伍数量为单数则在后面补数字“0”凑成双数。 如：参赛队伍为1、2、3、4、5、6、7等七支队伍，则将其分成1、2、3、4和5、6、7、0俩部分。 二、分为俩部分后，前一部分由1号开始，自上而下写在左边；后一部分的数自下而上写在右边，然后用横线把相对的号数连接起来。这即是第一轮的比赛。 l r 1 ---- 0 2 ---- 7 3 ---- 6 4 ---- 5 三、第二轮开始将第一轮右上角的编号(“0”或最大的一个代号数)移到左角上，第三轮又移回右角上，以此类推。即单数轮次时“0”或最大的一个代号在右上角，双数轮次时则在左上角。且每轮将除了“0”或最大一个代号以外的每个位置的数字，沿逆时针方向移动n（n等于(队伍数量-1)/2取整）个位置，当然移动时遇到“0”或最大的一个代号则跳过。同样以队伍数量7为例子, 其第二轮的对阵表应： 1) 将第一轮右上角的编号(“0”或最大的一个代号数)移到左角上 l r 1(原来) 0(现在) ---- null 2 ---- 7 3 ---- 6 4 ---- 5 2) 将除了“0”或最大一个代号以外的每个位置的数字，沿逆时针方向移动3（(队伍数量-1)/2取整）个位置，当然移动时遇到“0”或最大的一个代号则跳过。下表为第二轮比赛的对阵表。 l r 0 ---- 5 6 ---- 4 7 ---- 3 1 ---- 2 3)重复步骤三，直至得出了最后一轮比赛的对阵表(如果比赛队伍数量为单数，则总共轮数为比赛队伍数量，否则，总共轮数为比赛队伍数量-1) 比赛队伍数量为7时，循环赛对阵总表如下： 第一轮 第二轮 第三轮 第四轮 第五轮 第六轮 第七轮 1－0 0－5 2－0 0－6 3－0 0－7 4－0 2－7 6－4 3－1 7－5 4－2 1－6 5－3 3－6 7－3 4－7 1－4 5－1 2－5 6－2 4－5 1－2 5－6 2－3 6－7 3－4 7－1 流程图 伪代码12345678910111213141516171819202122232425262728293031323334353637begininput 比赛队伍数量numset resArr = [], arr = []// 初始化第一轮的队伍以及轮数等数据for: i = 1,2,...,num resArr.push(i)set times = num - 1if num%2 == 1 resArr[num] = 0 times = times + 1// 依次输出各轮对阵队伍for: count = 1,2,...,times output 轮数count // 输出本轮对阵队伍 for: n = 0,1,...,times/2取整 output 对阵的俩支队伍resArr[n], resArr[times-n] // 将第一轮右上角的编号(“0”或最大的一个代号数)移动 if count%2 == 0 arr[0] = resArr[times] else arr[times] = resArr[0] // 求得各个位置的数字移动的步数 set step = (num-1)/2取整 // 逆时针移动每个位置数字(除&apos;0&apos;或者最大编号)的位置，并遇到&apos;0&apos;或最大编号跳过 for: n = 0,1,...,times arr[(n&gt;(times+1-count%2-step?n+3:n+4))%times] =lastArr[n] // 每轮对阵队伍的更新 lastArr = arr arr = []end JavaScript代码ES512345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 使用贝格尔排列法获取比赛对阵表 * @param &#123;number&#125; num - 比赛队伍数量 * @return &#123;array&#125; - 表示比赛对阵表的三维数组 */function bergerMethod(num) &#123; // 格式不满足时抛出错误 if(typeof num !== 'number' || num &lt; 2) throw new Error('输入非数字或小于2'); // 初始化结果数组和比赛轮数 var resArr = [], times = num - 1; // 初始化第一轮数组(先创建一定长度的数组，再添加速度上可以更快一些) var arr = new Array(num); for(var i = 0; i &lt; arr.length; i++) &#123; arr[i] = i + 1; &#125; resArr[0] = arr; // 如果队伍数量是单数则将0添加，凑成双数,并且将轮数增1 if(num%2) &#123; arr[num] = 0; times++; &#125; // 求得各个位置的数字需要逆时针移动的步数 var step = (num-1)/2|0; var round = 2; do&#123; var curArr = [], lastArr = resArr[resArr.length - 1]; // 将第一轮右上角的编号(“0”或最大的一个代号数)移动 if(round%2) &#123; curArr[times] = lastArr[0]; &#125; else &#123; curArr[0] = lastArr[times]; &#125; var len = lastArr.length; for(var idx = 0; idx &lt; len; idx++) &#123; if(lastArr[idx] === 0 || lastArr[idx] === len) continue; // 逆时针移动数字 curArr[(idx&gt;=len-round%2-step ? idx+4 : idx+3)%len] = lastArr[idx] &#125; resArr.push(curArr); round++; &#125; while(round &lt;= times) // 将数组中的循环数组映射为对赛数组 resArr = resArr.map(function(v) &#123; var arr = [], len = v.length; for(var i = 0; i &lt; len/2; i++) &#123; arr.push([v[i], v[len-i-1]]); &#125; return arr; &#125;); return resArr;&#125; ES6除了用let取代var、箭头函数、以及利用Array.from形成密集数组的小机灵外与ES5版本也没什么不同…12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 使用贝格尔排列法获取比赛对阵表 * @param &#123;number&#125; num - 比赛队伍数量 * @return &#123;array&#125; - 表示比赛对阵表的三维数组 */const bergerMethod = num =&gt; &#123; // 格式不满足时抛出错误 if(typeof num !== 'number' || num &lt; 2) throw new Error('输入非数字或小于2'); // 初始化结果数组和比赛轮数 let resArr = [], times = num - 1; // 初始化第一轮数组 let arr = Array.from(&#123;length: num&#125;).map((v, i) =&gt; i + 1); resArr[0] = arr; // 如果队伍数量是单数则将0添加，凑成双数,并且将轮数增1 if(num%2) &#123; arr[num] = 0; times++; &#125; // 求得各个位置的数字需要逆时针移动的步数 let step = (num-1)/2|0; let round = 2; do&#123; let curArr = [], lastArr = resArr[resArr.length - 1]; // 将第一轮右上角的编号(“0”或最大的一个代号数)移动 if(round%2) &#123; curArr[times] = lastArr[0]; &#125; else &#123; curArr[0] = lastArr[times]; &#125; var len = lastArr.length; for(let idx = 0; idx &lt; len; idx++) &#123; if(lastArr[idx] === 0 || lastArr[idx] === len) continue; // 逆时针移动数字 curArr[(idx&gt;=len-round%2-step ? idx+4 : idx+3)%len] = lastArr[idx] &#125; resArr.push(curArr); round++; &#125; while(round &lt;= times) // 将数组中的循环数组映射为对赛数组 resArr = resArr.map(v =&gt; &#123; var arr = [], len = v.length; for(let i = 0; i &lt; len/2; i++) &#123; arr.push([v[i], v[len-i-1]]); &#125; return arr; &#125;); return resArr;&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yuyanggong.github.io/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://yuyanggong.github.io/tags/算法/"}]},{"title":"git多账号配置","date":"2017-09-06T19:22:18.757Z","path":"2017/09/07/多git账号配置/","text":"最近需要在本地电脑上配置多个git账号，通过ssh与多个远程仓库一一对应连接，稍微研究了下，便把一点心得写了下来。其步骤分为以下六点。 安装相关软件 创建公私密钥 上传密钥 配置config文件 验证与服务器是否联通 配置本地邮箱与用户名 一、安装相关软件如题所述，要完成此次配置，我们需要git和ssh。可以通过下面的命令来检查电脑是否已安装git：1git --version 若安装，则会正确显示版本信息。如果没有安装git，可以直接在官网下载，然后进行安装。ssh也会伴随git一起下载下来。 二、创建公私密钥我们用ssh-keygen这个命令来生成我们的密钥。1ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" 其中 -t选项指定我们的密钥算法，包括【RSA】和【DSA】两种，这里我们使用【RSA】算法。 -b选项指定我们的密钥长度，对于我们的【RSA】算法，默认是2048位，最小要求768位，这里我们使用4096位，位数越高，密钥安全性越强，而生成及匹配验证的速度也越慢。 -C选项提供一个新注释，这里我们用我们的邮箱当做注释，标识是我们自己，对git和ssh的配置无实际影响还有其他的参数，具体可以参考这篇博文 如上可知，我们也可以偷懒,不带任何参数直接：1ssh-key 相当于1ssh-keygen -t rsa -b 2048 接着执行此命令后，控制台显示以下内容123$ ssh-keygen -t rsa -b 4096 -C \"yuyang421736079@gmail.com\"Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/Administrator.PC-20140704RUOW/.ssh/id_rsa): 这里提示我们输入密钥文件所保存的文件路径，默认路径为~/.ssh/id_rsa，这里必须是绝对路径，在我这个例子里默认路径是/c/Users/Administrator.PC-20140704RUOW/.ssh/id_rsa，即我们创建的密钥会被保存在/c/Users/Administrator.PC-20140704RUOW/.ssh/文件夹中，其文件名为id_rsa。 我们的目的是git多账号配置，所以不希望使用默认路径，这样会创建相同的密钥文件名，造成冲突。这里我们根据个人情况键入[.ssh文件夹路径]/[密钥文件名]。在我的例子中键入的是/c/Users/Administrator.PC-20140704RUOW/.ssh/github_ssh回车后提示我们设置密码1Enter passphrase (empty for no passphrase): 密码可输入可不输入，如果不想输入直接回车, 代表设置密码为空。1Enter same passphrase again: 提示我们确认密码, 因为上一步我直接回车，设置密码为了空, 所以这里也直接回车即可确认设置的密码后，便会在控制台打印出生成密钥的结果信息，总体大致如下123456789101112131415161718192021$ ssh-keygen -t rsa -b 4096 -C \"yuyang421736079@gmail.com\"Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/Administrator.PC-20140704RUOW/.ssh/id_rsa): /c/Users/Administrator.PC-20140704RUOW/.ssh/github_sshEnter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/Administrator.PC-20140704RUOW/.ssh/github_ssh.Your public key has been saved in /c/Users/Administrator.PC-20140704RUOW/.ssh/github_ssh.pub.The key fingerprint is:SHA256:1iDpAR2sEeak7AR2sEe0lD/fDday3o190R8WgGhDWj4TQszic yuyang421736079@gmail.comThe key's randomart image is:+---[RSA 4096]----+| .. oo...oo|| . .. .++oo o|| . + o..+ .oo o || . = * ..oE o + .|| + * o S+.X o . || + o .. * = || + + . . || + . || . |+----[SHA256]-----+ 如上我们便成功生成了github的密钥，文件名为github_ssh,在文件夹~/.ssh中利用ls命令可以看到12$ lsgithub_ssh github_ssh.pub 其中github_ssh是我们的私钥github_ssh.pub是我们的公钥用同样的办法生成我们名为gitlab_ssh密钥 然后我们再通过ssh-agent命令注册ssh代理，以后可以通过这个管理我们的密钥(关于ssh-agent的介绍可以看这篇博文)1ssh-agent bash 此时ls命令在控制台中打印的内容:12$ lsgithub_ssh github_ssh.pub gitlab_ssh gitlab_ssh.pub 当然创建了密钥还是不够的，ssh默认只能识别在默认路径默认文件名的密钥(~/.ssh/id_rsa或~/.ssh/id_dsa)，我们需要告诉我们的ssh如何正确拿到我们的密钥，如下：1ssh-add ~/.ssh/[你的密钥文件名(私钥)] 在我们这例子中是1ssh-add ~/.ssh/github_ssh 1ssh-add ~/.ssh/gitlab_ssh 三、上传密钥在上面的操作中我们成功的生成了两组密钥，接下来我们要将这两组密钥分别上传到我们相应的github和gitlab账号上去。先通过cat命令将公钥打印出来123456$ cat github_ssh.pubssh-rsa hDyLa+xsXvFwHxyOKfJqly5OaJrHuIwesPXnO5RC/QVJzQ0Y2Oep9PWn5X6f4wOkhMnKh+Lvn0aVoKsuk7iQeIStrSBiEGeS1hkqbcliKIVjoB76IRRfSjp+Be0AAAAB3NzaC1yc2EAAAADAQABAARAcsgqCRGf5zppuShb53gq0pMu1MrblUWYf9JuABAQC2hF4YP8UkE+Sb2awY0u2po4k1nlnVD4GNP56HnvyFQZk18wAkBrTcKz0Uv8pFb5HtH7+lv3NzU4xOhU2aKfbnJBWHtpAQbXq4QWlgByEiMx/AKlXSkdyRcCCzB2dseUI7Dc6uBH4XfaNsCnv6/d/9gV00KJeREVHRSJEiBO6X0MXSZufdJ+P yuyang421736079@gmail.com 然后复制公钥，进入相应网站的setting界面，在SSH设置中添加我们的公钥。 四、配置config文件在~/.ssh文件夹中创建名为config的文件1touch config 然后配置config, 其文件内容大致如下1234567891011Host github.com HostName github.com User 421736079@qq.com PreferredAuthentications publickey IdentityFile /c/Users/Administrator.PC-20140704RUOW/.ssh/github_sshHost gitlab.com HostName gitlab.com User yuyang421736079@gmail.com PreferredAuthentications publickey IdentityFile /c/Users/Administrator.PC-20140704RUOW/.ssh/gitlab_ssh 如上，每个git账号需要配置一系列的Host HostName User PreferredAuthentications IdentityFile其中: Host 我们连接的这个网站你所设置的名称 HostName 真实的域名地址 User 使用用户 PreferredAuthentications 登录时权限认证形式，可设为: publickey 只验证公钥 password 只验证密码 password publickey 公钥和密码都验证 IdentityFile 密钥所在文件的绝对路径 五、验证与服务器是否联通可以通过以下命令来验证密钥是否可以成功连接远程服务器1ssh -T git@[远程服务器地址] 这里以github为例1ssh -T git@github.com 然后bash shell会打印以下信息：123The authenticity of host 'github.com (192.30.255.113)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7RomTxdCE1IGOCspARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? 密钥第一次连接远程服务器，会出现这样的询问，直接输入yes回车确定即可此时bash中会显示如下信息12Warning: Permanently added 'github.com,192.30.255.113' (RSA) to the list of known hosts.Hi yuyang! You've successfully authenticated, but GitHub does not provide shell access. 第一行的意思是将我们放置在github上的公钥添置到~/.ssh的known_hosts文件中，之后对github的每次连接都会检查其公钥与我们保存在known_hosts中的公钥是否相同，可以简单的避免一些安全问题。(若没有此文件，ssh会自动生成) 第二行代表我们验证通过，可以成功连接github。 六、配置本地邮箱与用户名当我们确认可以连接远程服务器后，每次从远程服务器clone仓库到本地时，还需要在本地配置邮箱与用户名，以标识作者1git config --local user.mail [你的用户名] 1git config --local user.email [你的邮箱] github上识别是否是同一作者的机制是邮箱地址，是否github账号邮箱地址与本地提交的邮箱地址相同。比如，当我github绑定的邮箱地址是421736079@qq.com，本地设置的邮箱地址却是yuyang421736079@gmail.com时，github则无法正确识别你的身份。当你push上远程仓库时，会发现：此时你需要正确设置本地邮箱地址1git config --local user.email 421736079@qq.com 然后再次push提交到远程仓库，ok, 现在github可以识别了。值得一提的是--local是git config的默认参数，当设置本地局部邮件地址时可以省略.如：1git config user.email 421736079@qq.com 等同于1git config --local user.email 421736079@qq.com 需要注意的是，当我们一时疏忽忘记设置本地邮箱地址时，git会向全局查找，即若我们之前通过git config --global user.email [你的邮箱地址]设置了全局邮箱地址，我们则会拿到这个全局的邮箱地址，哪怕这个地址并不是我们所期望的，为了避免这种事情的发生，我认为多git账号下的最佳实践就是，永远不要在多git账号的情况下配置全局邮箱地址 而当你全局和本地邮箱地址都没有设置时，进行git commit操作，控制台会提示你设置(避免了默认以global邮箱地址作为local邮箱地址)12345678$ git commit -m &quot;test: test for git&quot;*** Please tell me who you are.Run git config --global user.email &quot;you@example.com&quot; git config --global user.name &quot;Your Name&quot;to set your account&apos;s default identity.Omit --global to set the identity only in this repository.fatal: unable to auto-detect email address (got &apos;Administrator@PC-20140704RUOW.(none)&apos;) 如果已经设置了全局的邮箱地址和用户名，可以通过以下命令进行重置1git config --unset --global user.name 1git config --unset --global user.email 小结个人使用git一直都是单账号，但之前的一次远程办公，需要私人的github账号和公司的gitlab账号并存，分别可以连接远程服务器。当时想着快捷，用的https连接，每次push都需要重新输入账号密码，很繁琐。而且因为本地和全局的邮箱地址设置问题，导致commit的作者信息也没有被正确识别，于是便想着仔细学习一下，便有了这篇博客，主要供自己日后复习所用，如果这篇博文能帮助到他人，也是一件值得开心的事情。 参考链接https://help.github.com/articles/connecting-to-github-with-ssh/http://blog.csdn.net/yanzhenjie1003/article/details/69487932?locationNum=4&amp;fps=1http://www.cnblogs.com/Kyouhui/p/6878963.htmlhttp://www.cnblogs.com/popfisher/p/5731232.htmlhttp://killer-jok.iteye.com/blog/1853451http://yijiebuyi.com/blog/4b5c272e7058cb331098250c8e98eb3e.html","tags":[{"name":"git","slug":"git","permalink":"https://yuyanggong.github.io/tags/git/"},{"name":"ssh","slug":"ssh","permalink":"https://yuyanggong.github.io/tags/ssh/"}]},{"title":"Underscore源码分析之公共方法与模板引擎的实现","date":"2017-03-25T02:12:35.758Z","path":"2017/03/25/underscore源码解析之公共方法与模板引擎/","text":"库名: underscore 源码地址: https://github.com/jashkenas/underscore 源码版本: 1.8.3 分析内容: 公共方法与模板引擎的实现 _.identity1234// 直接返回传入的参数, 作为underscore的默认迭代器_.identity = function(value) &#123; return value;&#125;; _.constant1234567// 一个二段函数, 第一段调用的时候传入一个value, 利用词法作用域链保存在内存中,// 在第二段函数(即内部函数)调用时返回这个value_.constant = function(value) &#123; return function() &#123; return value; &#125;;&#125;; _.noop12// 无论传入什么参数都返回undefined, 在内部做默认可选的迭代器函数_.noop = function()&#123;&#125;; _.propertyOf12345678// 返回对象特定的某个属性_.propertyOf = function(obj) &#123; // 在obj为null、undefined时返回一个空对象, 避免边界情况报错 // 如错误的读取了null上的属性 return obj == null ? function()&#123;&#125; : function(key) &#123; return obj[key]; &#125;;&#125;; _.matcher12345678910111213141516171819202122 // 检测是否函数上具有相应的键值对 _.matcher = _.matches = function(attrs) &#123; // 拷贝attrs, 这里拷贝的原因是怕原attrs在后续被修改。 // 因为传的是引用, 所以外部的修改也会影响到内部。 attrs = _.extendOwn(&#123;&#125;, attrs); return function(obj) &#123; return _.isMatch(obj, attrs); &#125;; &#125;; ``` #### _.times```javascript // 执行一个函数n次, 并将这n次执行的返回值以一个数组的形式一起返回 _.times = function(n, iteratee, context) &#123; // acuum数组, 用以保存函数执行的返回值 var accum = Array(Math.max(0, n)); iteratee = optimizeCb(iteratee, context, 1); // 一次执行, 并每次分别传入i参数 for (var i = 0; i &lt; n; i++) accum[i] = iteratee(i); return accum; &#125;; _.random12345678// 返回一个介于min与max(包括max)之间的随机值。_.random = function(min, max) &#123; if (max == null) &#123; max = min; min = 0; &#125; return min + Math.floor(Math.random() * (max - min + 1));&#125;; _.now1234// 获取目前时间的时间戳_.now = Date.now || function() &#123; return new Date().getTime();&#125;; .escape与.unescape12345678910111213141516171819202122232425262728293031// 转义字符编码表var escapeMap = &#123; '&amp;': '&amp;amp;', '&lt;': '&amp;lt;', '&gt;': '&amp;gt;', '\"': '&amp;quot;', \"'\": '&amp;#x27;', '`': '&amp;#x60;'&#125;;// 转义字符解码表var unescapeMap = _.invert(escapeMap);// 解码/编码HTML转义字符的函数var createEscaper = function(map) &#123; // 返回编码/解码表中属性对应的值 var escaper = function(match) &#123; return map[match]; &#125;; // 用于查询需要被替换字符的正则表达式 var source = '(?:' + _.keys(map).join('|') + ')'; // 测试正则 var testRegexp = RegExp(source); // 替换正则 var replaceRegexp = RegExp(source, 'g'); return function(string) &#123; string = string == null ? '' : '' + string; return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string; &#125;;&#125;;_.escape = createEscaper(escapeMap);_.unescape = createEscaper(unescapeMap); _.result1234567891011// 如果object[prop]是一个函数, 则以object为上下文调用object[prop], // 如果object[prop]不存在, 但是fallback存在且为函数,// 则以object为上下文调用fallback,// 以上都不是, 则返回object[prop], 不存在时返回fallback_.result = function(object, prop, fallback) &#123; var value = object == null ? void 0 : object[prop]; if (value === void 0) &#123; value = fallback; &#125; return _.isFunction(value) ? value.call(object) : value;&#125;; #### _.uniqueId123456// // 生成一个独一无二的ID, 仅仅在浏览器session中有效。var idCounter = 0;_.uniqueId = function(prefix) &#123; var id = ++idCounter + ''; return prefix ? prefix + id : id;&#125;; 模板引擎123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109 // 用来匹配相应模板的正则, 可以修改来自定义 _.templateSettings = &#123; // 匹配表达式 evaluate: /&lt;%([\\s\\S]+?)%&gt;/g, // 匹配不需要转义的字符串 interpolate: /&lt;%=([\\s\\S]+?)%&gt;/g, // 匹配需要转义的字符串 escape: /&lt;%-([\\s\\S]+?)%&gt;/g &#125;; // 一个永远无法匹配成功的正则, /$(.)/ 也可以达到类似的效果 // 当在自定义`templateSettings`时 // 不想定义interpolate或者escape可以这么用 var noMatch = /(.)^/; // 需要转义才能在字符串字面量中使用 var escapes = &#123; \"'\": \"'\", '\\\\': '\\\\', '\\r': 'r', '\\n': 'n', '\\u2028': 'u2028', '\\u2029': 'u2029' &#125;; var escapeRegExp = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g; var escapeChar = function(match) &#123; return '\\\\' + escapes[match]; &#125;; // 模板核心代码 _.template = function(text, settings, oldSettings) &#123; // 如果settings不存在而oldSettings存在, 则使用oldSettings if (!settings &amp;&amp; oldSettings) settings = oldSettings; // 创建一个空对象, 并通过defaults使其继承settings和_.templateSettings // 优先保留settings中的属性 settings = _.defaults(&#123;&#125;, settings, _.templateSettings); // 将模板边界判断转换为正则表达式 // Ps: 这里也匹配了结束边界$, 以便匹配到末尾的字符串内容 var matcher = RegExp([ (settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source ].join('|') + '|$', 'g'); // 编译模板, 转义字符串字面量 var index = 0; // 在模板内部编译时候, 把编译后的字符串保存在内部的__p变量中 var source = \"__p+='\"; // 匹配模板内容 text.replace(matcher, function(match, escape, interpolate, evaluate, offset) &#123; // index到offset之间, 即不包括在任何模板边界当中的内容属于普通字符串, // 只需要转义字符串处理便可添加 source += text.slice(index, offset).replace(escapeRegExp, escapeChar); // 手动调整index位置, 移动到match后面的位置 index = offset + match.length; // 如果匹配到编码模板边界 if (escape) &#123; // 在模板内部, 将escape赋值给内部的变量__t, 然后判断其是否存在, // 存在的话就用_.escape来解码后添加, 否则添加空字符串 source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\"; &#125; else if (interpolate) &#123; // 同上, 只不过这里的interpolate不解码直接添加 source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\"; &#125; else if (evaluate) &#123; // evaluate表达式放在内部的字符串之外 source += \"';\\n\" + evaluate + \"\\n__p+='\"; &#125; return match; &#125;); source += \"';\\n\"; // 如果没有指明变量, 则绑定传入的obj(不存在时候绑定&#123;&#125;)在其作用域上 if (!settings.variable) source = 'with(obj||&#123;&#125;)&#123;\\n' + source + '&#125;\\n';// 进行内部的变量定义, 定义__t作为一个中间变量,供后续使用,// __p则用来保存结果字符串, __j指向数组原型链上的join方法,// 并在内部再创建一个print函数, 可连接参数, 供用户使用 source = \"var __t,__p='',__j=Array.prototype.join,\" + \"print=function()&#123;__p+=__j.call(arguments,'');&#125;;\\n\" + source + 'return __p;\\n'; var render; try &#123; // 以new Function来创建模板编译后执行的函数, 将setting.variable(不存在时候为obj) // 和'_'作为形参, source作为函数体 render = new Function(settings.variable || 'obj', '_', source); &#125; catch (e) &#123; // 如果创建时错误, 则抛出e, 并把source挂载在e上, // 可以在外部捕获错误并打印其source属性, 以进行错误分析 e.source = source; throw e; &#125;// 包装模板函数, 内部绑定this到目前的上下文, 且传入date和_为实参 var template = function(data) &#123; return render.call(this, data, _); &#125;; // 为了方便预编译提供的一个编译source // 这一步确定argument var argument = settings.variable || 'obj'; // 将一个包含函数的字符串挂载在模板函数的source属性上 template.source = 'function(' + argument + ')&#123;\\n' + source + '&#125;'; return template; &#125;;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yuyanggong.github.io/tags/JavaScript/"},{"name":"Underscore","slug":"Underscore","permalink":"https://yuyanggong.github.io/tags/Underscore/"},{"name":"源码分析","slug":"源码分析","permalink":"https://yuyanggong.github.io/tags/源码分析/"}]},{"title":"Underscore源码分析之函数与对象方法","date":"2017-03-23T15:28:08.180Z","path":"2017/03/23/underscore源码解析之函数方法与对象方法/","text":"库名: underscore 源码地址: https://github.com/jashkenas/underscore 源码版本: 1.8.3 分析内容: 函数方法与对象方法实现 函数方法executeBound12345678910var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) &#123; // 这一步判断是不是用 new 实例化构造函数 // 如果不是, 直接用apply绑定this执行后返回 if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args); // 如果是new实例化构造函数的话, 则模拟new函数内部实现 var self = baseCreate(sourceFunc.prototype); var result = sourceFunc.apply(self, args); if (_.isObject(result)) return result; return self;&#125;; _.bind123456789// 模拟原生Array.prototype.bind_.bind = restArgs(function(func, context, args) &#123; // 只能处理函数, 不是函数直接扔出错误 if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function'); var bound = restArgs(function(callArgs) &#123; return executeBound(func, bound, context, this, args.concat(callArgs)); &#125;); return bound;&#125;); _.partial123456789101112131415161718192021 // 局部应用一个函数填充在任意个数的 arguments， // 不改变其动态this值。和bind方法很相近。你可以传递_(用户可以自定义)给arguments列表 // 来指定一个不预先填充，但在调用时提供的参数。 _.partial = restArgs(function(func, boundArgs) &#123; // 获取参数占位符 var placeholder = _.partial.placeholder; var bound = function() &#123; var position = 0, length = boundArgs.length; var args = Array(length); for (var i = 0; i &lt; length; i++) &#123; // 进行占位符的替换 args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i]; &#125; while (position &lt; arguments.length) args.push(arguments[position++]); return executeBound(func, bound, this, this, args); &#125;; return bound; &#125;);// 可以通过修改_.partial.placeholder来自定义占位符 _.partial.placeholder = _; _.bindAll12345678910// 将obj上的方法的this绑定在obj上_.bindAll = restArgs(function(obj, keys) &#123; keys = flatten(keys, false, false); var index = keys.length; if (index &lt; 1) throw new Error('bindAll must be passed function names'); while (index--) &#123; var key = keys[index]; obj[key] = _.bind(obj[key], obj); &#125;&#125;); _.memoize12345678910111213// 通过 缓存函数结果 来优化函数_.memoize = function(func, hasher) &#123; var memoize = function(key) &#123; // 缓存放在memoize对象上 var cache = memoize.cache; // hasher用来处理传的参数保存在cache中的键名 var address = '' + (hasher ? hasher.apply(this, arguments) : key); if (!_.has(cache, address)) cache[address] = func.apply(this, arguments); return cache[address]; &#125;; memoize.cache = &#123;&#125;; return memoize;&#125;; _.delay123456// 延迟执行函数_.delay = restArgs(function(func, wait, args) &#123; return setTimeout(function() &#123; return func.apply(null, args); &#125;, wait);&#125;); _.defer123// 另一个函数异步执行, 在函数调用栈空了以后再执行// 比较好奇为什么这里是1不是直接设置为0_.defer = _.partial(_.delay, _, 1); _.throttle123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 创建并返回一个像节流阀一样的函数，当重复调用函数的时候，至少每隔 wait毫秒调用一次该函数。_.throttle = function(func, wait, options) &#123; var timeout, context, args, result; // 保留上一次调用时的时间戳 var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; // 如果设置options.leading为false的话, 那么第一次调用不会执行 // 需要过wait秒后的调用才执行 previous = options.leading === false ? 0 : _.now(); // 打断timeout对此later的引用, 释放内存 timeout = null; // 执行函数 result = func.apply(context, args); // 如果目前没有timeout, 即没有延迟执行的函数, 则打断context和args的引用 if (!timeout) context = args = null; &#125;; var throttled = function() &#123; // 获取目前的时间 var now = _.now(); // 如果是第一次调用或者其options.leading为false, 则让前一次的时间为本次时间 if (!previous &amp;&amp; options.leading === false) previous = now; // 计算剩余时间, 如果是第一次或者options.leading为false时, 这里应为wait var remaining = wait - (now - previous); // 报错上下文和参数的引用 context = this; args = arguments; // 如果剩余时间小于0, // 或者大于等待时间 // (判断大于等待时间是为了在用户代理的本地时间被修改时就立即执行函数) if (remaining &lt;= 0 || remaining &gt; wait) &#123; // 如果已经有timeout存在, 则清空已存在的timeout if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; // 改变上一次的执行时间previous previous = now; // 执行函数并保存返回值 result = func.apply(context, args); // 如果timeout不存在则打断引用 if (!timeout) context = args = null; // 如果timeout不存在, 且options.trailing不为false, // 则设置remaining剩余时间以后执行函数 &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; return result; &#125;; // 挂载在throttled上的取消方法, // 用来重置throttled的状态, 打断timeout、context、args的引用 throttled.cancel = function() &#123; clearTimeout(timeout); previous = 0; timeout = context = args = null; &#125;; // 返回thrttled方法, 每次创建都是一个新的throttled，利用闭包 // 产生了与new实例化类似的效果 return throttled;&#125;; _.debounce12345678910111213141516171819202122232425262728293031323334353637383940// 返回func函数的防反跳版本, 将延迟函数的执行(真正的执行)// 在函数最后一次调用时刻的 wait 毫秒之后, 如果传入immediate一个真值// 则第一次会直接调用(真正的调用)_.debounce = function(func, wait, immediate) &#123; var timeout, result; var later = function(context, args) &#123; // 打断timeout对此函数的引用 timeout = null; // 如果args参数存在, 则以context为上下文传入args参数调用 if (args) result = func.apply(context, args); &#125;; var debounced = restArgs(function(args) &#123; // 如果有timeout存在, 则清除 if (timeout) clearTimeout(timeout); // 如果immediate为真, 且是第一次调用则执行函数, 类似节流throttled if (immediate) &#123; var callNow = !timeout; // 不传参, 在later中不会执行 timeout = setTimeout(later, wait); if (callNow) result = func.apply(this, args); // 如果不为真, 则照常延迟执行 &#125; else &#123; timeout = _.delay(later, wait, this, args); &#125; return result; &#125;); // 挂载在debounced上的取消方法, // 用来重置debounced的状态, 打断timeout的引用 debounced.cancel = function() &#123; clearTimeout(timeout); timeout = null; &#125;; // 返回debounced return debounced;&#125;; _.wrap12345// 将第一个函数 func 封装到函数 wrapper 里面, 并把函数 func// 作为第一个参数传给 wrapper_.wrap = function(func, wrapper) &#123; return _.partial(wrapper, func);&#125;; _.negate123456// 返回predicate的逆版本_.negate = function(predicate) &#123; return function() &#123; return !predicate.apply(this, arguments); &#125;;&#125;; _.compose1234567891011// 返回一个组合函数, 会依次从右到左调用函数_.compose = function() &#123; var args = arguments; var start = args.length - 1; return function() &#123; var i = start; var result = args[start].apply(this, arguments); while (i--) result = args[i].call(this, result); return result; &#125;;&#125;; _.after123456789// 返回一个函数, 其只有在times次调用以后才能被执行_.after = function(times, func) &#123; return function() &#123; // 简单的利用闭包机制保存times, 用times监控调用情况 if (--times &lt; 1) &#123; return func.apply(this, arguments); &#125; &#125;;&#125;; _.before123456789101112// 返回一个函数, 其只有前times-1次调用会被执行_.before = function(times, func) &#123; var memo; return function() &#123; if (--times &gt; 0) &#123; memo = func.apply(this, arguments); &#125; // times-1次后, 打断引用, 清理内存 if (times &lt;= 1) func = null; return memo; &#125;;&#125;; _.once12// 返回一个函数只能在第一次调用时候被执行_.once = _.partial(_.before, 2); 对象方法_.keys1234567891011121314151617// 获取对象的键名, 并以数组的形式返回// 类似es5中原生的`Object.keys`._.keys = function(obj) &#123; // 如果不是对象, 则直接返回空数组 if (!_.isObject(obj)) return []; // 如果原生方法存在则直接使用原生方法 if (nativeKeys) return nativeKeys(obj); var keys = []; // 遍历obj上的可枚举属性, 用_.has判断是否是其自身的属性(非原型链上) // 如果是的话, 就push进结果数组中 for (var key in obj) if (_.has(obj, key)) keys.push(key); // IE9以下有bug, 需要针对处理 // (主要是部分原型链上的同名方法如toString等经hasOwnProperty会错误的返回false // 以及for in无法枚举constructor，哪怕自身上已经重写, 且设置为可枚举 if (hasEnumBug) collectNonEnumProps(obj, keys); return keys;&#125;; 解决_.keys中存在于IE9的bug123456789101112131415161718192021222324// 判断是否有枚举bugvar hasEnumBug = !&#123;toString: null&#125;.propertyIsEnumerable('toString');// 这些属性在有枚举bug时, 哪怕在自身对象上重写, 也不会被枚举var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];var collectNonEnumProps = function(obj, keys) &#123; var nonEnumIdx = nonEnumerableProps.length; var constructor = obj.constructor; // 有原型就使用原型, 如果没有则使用Object.prototype var proto = _.isFunction(constructor) &amp;&amp; constructor.prototype || ObjProto; // Constructor不会被for in枚举, 但是可以通过hasOwnProperty判断 var prop = 'constructor'; if (_.has(obj, prop) &amp;&amp; !_.contains(keys, prop)) keys.push(prop); while (nonEnumIdx--) &#123; prop = nonEnumerableProps[nonEnumIdx]; // 判断1、是否是是obj上的可枚举对象, 2、是否不在原型链上, 3、结果中是否已经包含 if (prop in obj &amp;&amp; obj[prop] !== proto[prop] &amp;&amp; !_.contains(keys, prop)) &#123; keys.push(prop); &#125; &#125;&#125;; _.allKeys123456789// 返回对象上的所有可枚举键名, 包括自身上的以及原型链上的_.allKeys = function(obj) &#123; if (!_.isObject(obj)) return []; var keys = []; for (var key in obj) keys.push(key); // IE9以下特殊处理 if (hasEnumBug) collectNonEnumProps(obj, keys); return keys;&#125;; _.values123456789101112// 返回对象自身上的所有可枚举属性的值_.values = function(obj) &#123; // 先获取其自身上所有可枚举属性的键名 var keys = _.keys(obj); var length = keys.length; var values = Array(length); // 根据先前获取的键名去拿属性值 for (var i = 0; i &lt; length; i++) &#123; values[i] = obj[keys[i]]; &#125; return values;&#125;; _.mapObject123456789101112// 与map相似，但用于对象。转换每个属性的值。_.mapObject = function(obj, iteratee, context) &#123; iteratee = cb(iteratee, context); var keys = _.keys(obj), length = keys.length, results = &#123;&#125;; for (var index = 0; index &lt; length; index++) &#123; var currentKey = keys[index]; results[currentKey] = iteratee(obj[currentKey], currentKey, obj); &#125; return results;&#125;; _.pairs12345678910// 将对象转换为键值对形式的二维数组_.pairs = function(obj) &#123; var keys = _.keys(obj); var length = keys.length; var pairs = Array(length); for (var i = 0; i &lt; length; i++) &#123; pairs[i] = [keys[i], obj[keys[i]]]; &#125; return pairs; &#125;; _.invert123456789// 反转对象的键值对_.invert = function(obj) &#123; var result = &#123;&#125;; var keys = _.keys(obj); for (var i = 0, length = keys.length; i &lt; length; i++) &#123; result[obj[keys[i]]] = keys[i]; &#125; return result;&#125;; _.functions12345678910// 返回对象上(包括原型链)可枚举的函数名, 并且对其排序_.functions = _.methods = function(obj) &#123; var names = []; // 遍历如果是函数, 则将键名push进names for (var key in obj) &#123; if (_.isFunction(obj[key])) names.push(key); &#125; // 排序并返回 return names.sort();&#125;; .extend与.extendOwn以及_.defaults123456789101112131415161718192021222324252627282930313233343536// 内部私有函数, 为了创建extend等方法。// 传入的keysFunc是一个用来获取当前对象的键值的函数,// defaults判断是否要覆盖目标对象上已存在的属性 var createAssigner = function(keysFunc, defaults) &#123; return function(obj) &#123; var length = arguments.length; // 如果defaults为真, 则先将obj转换为对象 if (defaults) obj = Object(obj); // 如果参数长度小于2, 或obj为null、undefined则直接返回obj。 if (length &lt; 2 || obj == null) return obj; // 遍历参数, 依次去拓展源对象 for (var index = 1; index &lt; length; index++) &#123; var source = arguments[index], keys = keysFunc(source), l = keys.length; for (var i = 0; i &lt; l; i++) &#123; var key = keys[i]; // 如果defaults为假, 则无视obj上已存在的同名属性, 直接覆盖 // 反之, 如果defaults为真, 且obj上已存在同名属性, 则跳过, 不覆盖 if (!defaults || obj[key] === void 0) obj[key] = source[key]; &#125; &#125; return obj; &#125;;&#125;;// 复制source对象中的所有属性覆盖到destination对象上，并且返回 destination 对象. // 复制是按顺序的, 所以后面的对象属性会把前面的对象属性覆盖掉(如果有重复).// 拓展也包括原型链上的属性._.extend = createAssigner(_.allKeys);// 与extend类似, 但是不包括原型链上的属性_.extendOwn = _.assign = createAssigner(_.keys); // 与_.extend类似, 但是会保留destination对象上已存在的属性_.defaults = createAssigner(_.allKeys, true); _.findKey1234567891011// 返回对象中第一个通过predicate的属性的键名_.findKey = function(obj, predicate, context) &#123; predicate = cb(predicate, context); var keys = _.keys(obj), key; for (var i = 0, length = keys.length; i &lt; length; i++) &#123; key = keys[i]; if (predicate(obj[key], key, obj)) return key; &#125; // 如果遍历完都没有查询到有符合predicate的属性, 则无返回值 // 等同于返回了undefined&#125;; _.pick1234567891011121314151617181920212223242526272829303132// 内部辅助函数, 用来检测obj对象及其原型链上是否有key属性var keyInObj = function(value, key, obj) &#123; return key in obj;&#125;;// 返回一个obj副本，只过滤出keys(有效的键组成的数组)参数指定的属性值。// 或者接受一个判断函数，指定挑选哪个key。_.pick = restArgs(function(obj, keys) &#123; var result = &#123;&#125;, iteratee = keys[0]; if (obj == null) return result; // 如果iteratee为函数, 则代表第二个传进来的参数是处理函数, 而不是key键 if (_.isFunction(iteratee)) &#123; // 如果keys的长度大于1, 则将其第二索引位的元素当成context传入优化函数中 if (keys.length &gt; 1) iteratee = optimizeCb(iteratee, keys[1]); // 获取obj对象上的所有键名, 包括所有自身及原型链上的可枚举属性 keys = _.allKeys(obj); &#125; else &#123; // 如果没有传入iteratee, 则用内置的keyInObj当默认iteratee iteratee = keyInObj; // 展平传入的keys keys = flatten(keys, false, false); // 将obj转换为对象 obj = Object(obj); &#125; // 遍历keys, 判断相应的属性是否通过predicate, 如果是的话则push进结果数组result for (var i = 0, length = keys.length; i &lt; length; i++) &#123; var key = keys[i]; var value = obj[key]; if (iteratee(value, key, obj)) result[key] = value; &#125; return result;&#125;); _.omit1234567891011121314151617// 返回一个obj副本，只过滤出除去keys参数指定的属性值。 // 或者接受一个判断函数predicate, 指定忽略哪个key。_.omit = restArgs(function(obj, keys) &#123; var iteratee = keys[0], context; // 如果传入的是判断函数, 则将其转换为否定版本传入_.pick中 if (_.isFunction(iteratee)) &#123; iteratee = _.negate(iteratee); if (keys.length &gt; 1) context = keys[1]; // 如果传入的不是判断函数, 则将其先展平, 再装换为字符串 &#125; else &#123; keys = _.map(flatten(keys, false, false), String); iteratee = function(value, key) &#123; return !_.contains(keys, key); &#125;; &#125; return _.pick(obj, iteratee, context);&#125;); _.create12345678910// 创建具有给定原型的新对象， 可选附加props 作为 返回对象 的属性。 // 基本上，和Object.create一样， 但是没有所有的属性描述符。_.create = function(prototype, props) &#123; // 以原型创建对象 var result = baseCreate(prototype); // 如果传入了props, 则将其自身上的可枚举属性添加到result对象上(会 // 覆盖result上已存在的同名属性) if (props) _.extendOwn(result, props); return result;&#125;; _.clone1234567// 创建一个对象的浅拷贝, 拷贝所有自身及原型链上的属性, 但是只是连接引用,// 并没有对属性也进行拷贝_.clone = function(obj) &#123; if (!_.isObject(obj)) return obj; // 对数组使用简便的slice, 对其他对象使用内置的_.extend方法 return _.isArray(obj) ? obj.slice() : _.extend(&#123;&#125;, obj);&#125;; _.tap123456789// 用 obj 作为参数来调用函数interceptor，然后返回object。// 这种方法的主要意图是作为函数链式调用的一环, // 为了对此对象执行操作并返回对象本身。_.tap = function(obj, interceptor) &#123; // 用interceptor操作obj interceptor(obj); // 返回obj return obj;&#125;; _.isMatch12345678910111213// 判断attrs中的键值对是否包含在object中。_.isMatch = function(object, attrs) &#123; var keys = _.keys(attrs), length = keys.length; // 当object为null或undefined, attrs为空的时候, 返回true if (object == null) return !length; var obj = Object(object); for (var i = 0; i &lt; length; i++) &#123; var key = keys[i]; // 当属性在obj中不存在 或 与attrs中的不相等时, 直接返回false if (attrs[key] !== obj[key] || !(key in obj)) return false; &#125; return true;&#125;; 私有方法eq与deepEq123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// 内部的递归比较函数, 用于_.isEqualvar eq, deepEq;eq = function(a, b, aStack, bStack) &#123; // 0 === -0 会错误的返回true, 所以需特殊处理 if (a === b) return a !== 0 || 1 / a === 1 / b; // 个人觉得这步多余了, 因为之前就判断了a===b的情况 if (a == null || b == null) return a === b; // 判断NaN, 因为NaN不等于自身, 需特殊处理 if (a !== a) return b !== b; var type = typeof a; // 判断其类型, 如果俩个都不是对象类型即返回true。 if (type !== 'function' &amp;&amp; type !== 'object' &amp;&amp; typeof b != 'object') return false; // a b都是对象, 则深入比较 return deepEq(a, b, aStack, bStack);&#125;;// Internal recursive comparison function for `isEqual`.deepEq = function(a, b, aStack, bStack) &#123; // 如果是_的实例, 则使用其_wrapped对象 if (a instanceof _) a = a._wrapped; if (b instanceof _) b = b._wrapped; // 比较class名(即构造函数的名字) var className = toString.call(a); // class名不同, 则直接返回true if (className !== toString.call(b)) return false; // 根据不同的class名进行相应的判断处理 switch (className) &#123; // Strings, numbers, regular expressions, dates, 和 booleans 直接通过值来比较 case '[object RegExp]': // RegExps 通过字符串形式比较 case '[object String]': // String 也通过字符串形式比较 // 如`\"5\"`与 `new String(\"5\")`相等. return '' + a === '' + b; case '[object Number]': // 通过对象是否等于自身来 判断NaN if (+a !== +a) return +b !== +b; // 判断是否为-0与+0, 是的话则通过 1/+a === 1/b来判断 return +a === 0 ? 1 / +a === 1 / b : +a === +b; case '[object Date]': case '[object Boolean]': // 通过转换为数字来比较 return +a === +b; case '[object Symbol]': // 通过其原型链上的valueOf来比较 return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b); &#125; var areArrays = className === '[object Array]'; if (!areArrays) &#123; // 如果任一不是对象, 则直接返回false if (typeof a != 'object' || typeof b != 'object') return false; // 比较构造函数, 如果构造函数不同, 则不相等, // 但是不同frame下的Object和Array不相等, 所以需特殊处理 var aCtor = a.constructor, bCtor = b.constructor; if (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; aCtor instanceof aCtor &amp;&amp; _.isFunction(bCtor) &amp;&amp; bCtor instanceof bCtor) &amp;&amp; ('constructor' in a &amp;&amp; 'constructor' in b)) &#123; return false; &#125; &#125; // 初始遍历对象的栈 // 因为只有数组或者对象的判断才需要栈, 所以放这里初始化 // 栈主要是为了判断数组或对象是否具有循环结构 aStack = aStack || []; bStack = bStack || []; var length = aStack.length; while (length--) &#123; // 线性查找, 这里主要是为了查询是否是循环结构。 if (aStack[length] === a) return bStack[length] === b; &#125; // 将第一个对象推入栈中 aStack.push(a); bStack.push(b); // 递归比较对象和数组 if (areArrays) &#123; // 先比较长度 length = a.length; if (length !== b.length) return false; // 深比较, 忽略键名非数字以外的属性 while (length--) &#123; if (!eq(a[length], b[length], aStack, bStack)) return false; &#125; &#125; else &#123; // 深比较对象 var keys = _.keys(a), key; length = keys.length; // 先比较属性的数量 if (_.keys(b).length !== length) return false; while (length--) &#123; // 深比较每个属性 key = keys[length]; // 如果b不存在此key属性, 或者存在但不与a中的相对, 则返回false if (!(_.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) return false; &#125; &#125; // 出栈 aStack.pop(); bStack.pop(); return true;&#125;; _.isEqual1234// 比较a、b是否相等, 利用内部私有的eq方法_.isEqual = function(a, b) &#123; return eq(a, b);&#125;; _.has1234// 判断key是否为obj自身的属性, 而非原型链上的属性_.has = function(obj, key) &#123; return obj != null &amp;&amp; hasOwnProperty.call(obj, key);&#125;; 类型判断1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// 判断一个对象是否为空(即其自身上不存在可枚举属性)_.isEmpty = function(obj) &#123; // 如果传入的obj为null或undefined, 直接返回true if (obj == null) return true; // 如果是数组、字符串、 arguments对象, 直接判断其length属性是否为0 if (isArrayLike(obj) &amp;&amp; (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0; // 其他情况通过_.keys判断其自身是否有可枚举的属性 return _.keys(obj).length === 0;&#125;;// 判断传入的对象是否是dom元素_.isElement = function(obj) &#123; // 通过nodeTyp来判断是否为dom元素 return !!(obj &amp;&amp; obj.nodeType === 1);&#125;;// 判断传入的obj是否为数组,// es5原生方法Array.isArray存在时则直接使用_.isArray = nativeIsArray || function(obj) &#123; // 利用Object.prototype.toString来判断 return toString.call(obj) === '[object Array]';&#125;;// 判断传入的obj是否为对象_.isObject = function(obj) &#123; var type = typeof obj; // 利用type直接判断, 我们知道typeof null也会返回object, 所以通过!!obj来过滤 return type === 'function' || type === 'object' &amp;&amp; !!obj;&#125;;// 添加一些类型判断函数: isArguments, isFunction, isString, isNumber, isDate, // isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet._.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) &#123; _['is' + name] = function(obj) &#123; // 使用Object.prototype.toString来判断 return toString.call(obj) === '[object ' + name + ']'; &#125;;&#125;);// 定义一个用于IE9以下的isArguments回退版本, if (!_.isArguments(arguments)) &#123; _.isArguments = function(obj) &#123; // 通过arguments上的callee来判断 return _.has(obj, 'callee'); &#125;;&#125;// 优化isFuncion函数, 并修复一些在浏览器中出现的bugvar nodelist = root.document &amp;&amp; root.document.childNodes;if (typeof /./ != 'function' &amp;&amp; typeof Int8Array != 'object' &amp;&amp; typeof nodelist != 'function') &#123; _.isFunction = function(obj) &#123; // 个人认为这里的false很多余 return typeof obj == 'function' || false; &#125;;&#125;// 判断传入的obj是否为有限_.isFinite = function(obj) &#123; return !_.isSymbol(obj) &amp;&amp; isFinite(obj) &amp;&amp; !isNaN(parseFloat(obj));&#125;;// 判断传入的obj是否为NaN_.isNaN = function(obj) &#123; // 先用isNumber判断其为数字, 在用isNaN判断 return _.isNumber(obj) &amp;&amp; isNaN(obj);&#125;;// 判断传入的obj是否为布尔类型_.isBoolean = function(obj) &#123; // 前者判断字面量形式创建的boolean, 后者判断new构造函数形式创建的boolean return obj === true || obj === false || toString.call(obj) === '[object Boolean]';&#125;;// 判断传入的obj是否为null_.isNull = function(obj) &#123; return obj === null;&#125;;// 判断传入的obj是否为undefined_.isUndefined = function(obj) &#123; // 为防止undefined被重写, 所以用void 0来判断 return obj === void 0;&#125;;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yuyanggong.github.io/tags/JavaScript/"},{"name":"Underscore","slug":"Underscore","permalink":"https://yuyanggong.github.io/tags/Underscore/"},{"name":"源码分析","slug":"源码分析","permalink":"https://yuyanggong.github.io/tags/源码分析/"}]},{"title":"Underscore源码分析之集合与数组方法","date":"2017-03-21T11:58:45.138Z","path":"2017/03/21/underscore源码解析之集合方法与数组方法/","text":"库名: underscore 源码地址: https://github.com/jashkenas/underscore 源码版本: 1.8.3 分析内容: 集合方法与数组方法实现 集合方法baseCreate12345678910111213141516 // 先创建一个没有任何方法、属性的\"空\"构造函数 var Ctor = function()&#123;&#125;; // 以prototype为原型创建新对象, 与Object.create方法相同 var baseCreate = function(prototype) &#123; // 如果传入的原型不是对象, 则返回空对象。 if (!_.isObject(prototype)) return &#123;&#125;; // 如果原生的Object.create存在, 则返回原生方法 if (nativeCreate) return nativeCreate(prototype);// 以上都不是的话, 则手动连接原型链, 模拟效果相同效果// 利用__proto__也可以实现等同效果, 但考虑到__proto__不在ES语言规范中, 故不推荐使用 Ctor.prototype = prototype; var result = new Ctor; Ctor.prototype = null; return result; &#125;; 为兼容低版本浏览器不支持Object.create而实现的一个兼容性函数。 optimizeCb123456789101112131415161718192021// 优化回调函数var optimizeCb = function(func, context, argCount) &#123; // 如果未传入上下文context则直接返回函数func if (context === void 0) return func; // 省却时默认argCount为3, 因为Underscore内部argCount为3的情况比较多,为了后续的简写少些 switch (argCount == null ? 3 : argCount) &#123; // 用实际参数替代arguments, 且优先使用call而不是apply。 case 1: return function(value) &#123; return func.call(context, value); &#125;; case 3: return function(value, index, collection) &#123; return func.call(context, value, index, collection); &#125;; case 4: return function(accumulator, value, index, collection) &#123; return func.call(context, accumulator, value, index, collection); &#125;; &#125; return function() &#123; return func.apply(context, arguments); &#125;;&#125;; 优化的原由： arguments的性能较差, 能不用就尽量少用 call和apply有一定的性能开销, 所以当没有需要绑定的上下文时, 则直接调用 call的速度又比apply的速度要快, 当需要绑定上下文调用函数时尽量用call cb1234567891011121314151617181920var builtinIteratee;// 内置回调函数, 返回可供Underscore内置迭代使用的函数var cb = function(value, context, argCount) &#123; // 当挂载在_实例上的iteratee迭代函数不等于内置builtinIteratee函数时候 // 即说明用户自定义了iteratee方法, 此时返回用户自定义的迭代方法。 if (_.iteratee !== builtinIteratee) return _.iteratee(value, context); // 如果value为null或者undefined时候, 返回_.identity作为迭代函数 // identity函数返回传入的第一个参数。 if (value == null) return _.identity; // 如果是函数, 则返回优化后的回调 if (_.isFunction(value)) return optimizeCb(value, context, argCount); // 如果是对象则通过matcher方法判断后续对象是否与此前对象所有属性相同 if (_.isObject(value)) return _.matcher(value); // 如果是值类型, 则通过property函数返回对象相关属性的值 return _.property(value);&#125;;// 用户可以通过修改_.iteratee来改变每次迭代的行为方式_.iteratee = builtinIteratee = function(value, context) &#123; return cb(value, context, Infinity);&#125;; 内置了一个builtinInteratee函数并将其引用与.iteratee方法连接起来, 每次执行cb时判定builtinInteratee与.iteratee是否相等, 如果不相等的话, 则代表用户修改了_.iteratee, 则cb优先使用用户修改的iteratee方法。 resArgs123456789101112131415161718192021222324// 包装函数func, 使其从startIndex位置以后传入的参数都为一个统一的数组var restArgs = function(func, startIndex) &#123; // startIndex在未被传参的时候默认为最后一位 startIndex = startIndex == null ? func.length - 1 : +startIndex; return function() &#123; var length = Math.max(arguments.length - startIndex, 0); var rest = Array(length); for (var index = 0; index &lt; length; index++) &#123; rest[index] = arguments[index + startIndex]; &#125; // 此处同optimizeCb函数一样, 是为了优化性能, 尽量使用call代替apply switch (startIndex) &#123; case 0: return func.call(this, rest); case 1: return func.call(this, arguments[0], rest); case 2: return func.call(this, arguments[0], arguments[1], rest); &#125; var args = Array(startIndex + 1); for (index = 0; index &lt; startIndex; index++) &#123; args[index] = arguments[index]; &#125; args[startIndex] = rest; return func.apply(this, args); &#125;;&#125;; 类似与es6中的rest param, 但是这里只能另处在末尾的参数为数组, 不能另中间的也为数组。eg: 可以做到这样：...b)```, 但是不能做到这样：```func(a, ...b, c)```123456789#### property```javascript // 先接收key, 然后可以依次调用在每个对象上以获取其相应的key属性 var property = function(key) &#123; return function(obj) &#123; // 如果obj为null或者undefined, 则直接返回void 0(等同于undefined) return obj == null ? void 0 : obj[key]; &#125;; &#125;; 这里用void 0 代替undefined的原因有: 防止undefined被覆盖, 在非严格模式下, undefined可以被重命名, 导致指向其他值, 如 123undefined = 1;console.log(undefined); // 1console.log(void 0); // undefined void 0 性能稍微比undefined快一些 其返回的函数对与null相等(这里不是严格相等, 所以也包括undefined)的输入做了判断, 如果为真, 则直接返回void 0, 这一步是为了防止直接读取null或undefined上面的属性而报错。123console.log(property('length')(null)); // undefinedconsole.log(property('length')(undefined)); // undefined console.log(null.length); // TypeError getLength12// 获取对象的长度var getLength = property('length'); 这里使用property去获取length, 而不是直接使用obj.length, 在功能方面, 避免了后续传入的obj为undefined或null时候报错。例子如下12console.log(getLength(null)); // undefinedconsole.log(null.length); // TypeError isArrayLike1234567// 判断是否是类数组, 根据其是否有length这个属性// 且其类型为number, 大于等于0且小于最大安全索引数var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;var isArrayLike = function(collection) &#123; var length = getLength(collection); return typeof length == 'number' &amp;&amp; length &gt;= 0 &amp;&amp; length &lt;= MAX_ARRAY_INDEX;&#125;; _.each12345678910111213141516171819// 遍历数组成员, 并用iteratee进行处理// (ps: 与原生相比,有几点不同,原生的forEach没有返回值,且会跳过数组稀疏位)_.each = _.forEach = function(obj, iteratee, context) &#123; iteratee = optimizeCb(iteratee, context); var i, length; // 如果是类数组, 则按照其索引, 以length为界限进行遍历 if (isArrayLike(obj)) &#123; for (i = 0, length = obj.length; i &lt; length; i++) &#123; iteratee(obj[i], i, obj); &#125; &#125; else &#123; // 非类数组的情况, 就根据其key-value对 进行遍历 var keys = _.keys(obj); for (i = 0, length = keys.length; i &lt; length; i++) &#123; iteratee(obj[keys[i]], keys[i], obj); &#125; &#125; return obj;&#125;; _.map1234567891011121314151617// 用iteratee迭代处理每个obj中的元素并返回, 以返回值组成新的对象_.map = _.collect = function(obj, iteratee, context) &#123; iteratee = cb(iteratee, context); // 如果不是类数组则将其键数组赋值给keys, 否则直接将false赋值给keys。 var keys = !isArrayLike(obj) &amp;&amp; _.keys(obj), // 获取内容长度, 如果keys存在则代表是非类数组, 即其length不合法 // 优先使用keys的长度 length = (keys || obj).length, // 预定义一个给定length的稀疏数组 results = Array(length); // 遍历数组元素, 处理后将返回值赋值给results上相应index位置元素 for (var index = 0; index &lt; length; index++) &#123; var currentKey = keys ? keys[index] : index; results[index] = iteratee(obj[currentKey], currentKey, obj); &#125; return results;&#125;; 这里没有先定义一个length长度为0的空数组, 而是预定义了一个给定length的稀疏数组, 因为后者性能比前者佳, 速度更快。 createReduce12345678910111213141516171819202122232425// 创造一个reduce辅助函数, 根据dir来判断其是从左向右遍历还是从右向左。var createReduce = function(dir) &#123; var reducer = function(obj, iteratee, memo, initial) &#123; // 这一部分与_.map中分析的相同 var keys = !isArrayLike(obj) &amp;&amp; _.keys(obj), length = (keys || obj).length, index = dir &gt; 0 ? 0 : length - 1; // 如果没有初始值, 则将对象中的第一个元素设为初始值, 并设置遍历从对象的第二个元素开始 if (!initial) &#123; memo = obj[keys ? keys[index] : index]; index += dir; &#125; // 循环需要满足俩个条件才会进入, index &gt;= 0是用来限制dir为-1的情况, index &lt; length是用来限制dir为1的情况 for (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123; var currentKey = keys ? keys[index] : index; memo = iteratee(memo, obj[currentKey], currentKey, obj); &#125; return memo; &#125;; return function(obj, iteratee, memo, context) &#123; var initial = arguments.length &gt;= 3; return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial); &#125;;&#125;; _.reduce12345// 利用createReduce函数创建一个reduce函数来累计值, 以计算总值_.reduce = _.foldl = _.inject = createReduce(1);// reduce的从左到右累计版本_.reduceRight = _.foldr = createReduce(-1); createReduce将共同逻辑封装了, 这里创建函数就显得很优雅, 简单易懂 _.find1234567// 返回数组或对象中第一个经predicate检查为真的元素_.find = _.detect = function(obj, predicate, context) &#123; // 类数组对象借助_.findIndex实现, 非类数组对象借助_.findKey实现 var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey; var key = keyFinder(obj, predicate, context); if (key !== void 0 &amp;&amp; key !== -1) return obj[key];&#125;; _.filter123456789// 返回数组或对象中所有经predicate检查为真的元素_.filter = _.select = function(obj, predicate, context) &#123; var results = []; predicate = cb(predicate, context); _.each(obj, function(value, index, list) &#123; if (predicate(value, index, list)) results.push(value); &#125;); return results;&#125;; _.reject123456// 返回数组或对象中所有经predicate检查为假值的元素_.reject = function(obj, predicate, context) &#123; // 借助_.negate实现predicate的取反 // 又因为_.negate只能接受函数为参数, 所以需要用cb函数转换一遍 return _.filter(obj, _.negate(cb(predicate)), context);&#125;; _.every1234567891011// 是否数组或对象中的所有元素值都经predicate函数返回true_.every = _.all = function(obj, predicate, context) &#123; predicate = cb(predicate, context); var keys = !isArrayLike(obj) &amp;&amp; _.keys(obj), length = (keys || obj).length; for (var index = 0; index &lt; length; index++) &#123; var currentKey = keys ? keys[index] : index; if (!predicate(obj[currentKey], currentKey, obj)) return false; &#125; return true;&#125;; _.some1234567891011// 是否数组或对象中的某一元素值经predicate函数返回true_.some = _.any = function(obj, predicate, context) &#123; predicate = cb(predicate, context); var keys = !isArrayLike(obj) &amp;&amp; _.keys(obj), length = (keys || obj).length; for (var index = 0; index &lt; length; index++) &#123; var currentKey = keys ? keys[index] : index; if (predicate(obj[currentKey], currentKey, obj)) return true; &#125; return false;&#125;; _.contains1234567// 从fromIndex开始查找(如果省缺或者传入了第四个参数guard且其为真,就从头开始), 如果obj包括item元素就返回true, 用===严格相等比较, _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) &#123; if (!isArrayLike(obj)) obj = _.values(obj); if (typeof fromIndex != 'number' || guard) fromIndex = 0; // 内部借助_.indexOf实现 return _.indexOf(obj, item, fromIndex) &gt;= 0;&#125;; _.invoke1234567891011// 以obj上的每个元素为上下文, 依次传入args参数来调用method函数_.invoke = restArgs(function(obj, method, args) &#123; var isFunc = _.isFunction(method); return _.map(obj, function(value) &#123; // 如果传入的func不是函数, 则在集合元素上取其键名等同于method的值 var func = isFunc ? method : value[method]; // 如果func存在则调用, 否则就返回func // 当func存在但不为函数时会报错 return func == null ? func : func.apply(value, args); &#125;);&#125;); _.pluck1234// 获取集合中每个元素key相应的值_.pluck = function(obj, key) &#123; return _.map(obj, _.property(key));&#125;; _.where1234// 返回集合中所有包含特定`key:value`对的元素_.where = function(obj, attrs) &#123; return _.filter(obj, _.matcher(attrs));&#125;; _.findWhere1234// 返回集合中第一个出现的包含特定`key:value`对的元素_.findWhere = function(obj, attrs) &#123; return _.find(obj, _.matcher(attrs));&#125;; _.max1234567891011121314151617181920212223242526272829303132// 返回集合中最大的元素 (如果存在iteratee, 则其大小的评估将基于iteratee计算)._.max = function(obj, iteratee, context) &#123; var result = -Infinity, lastComputed = -Infinity, value, computed; if (iteratee == null || (typeof iteratee == 'number' &amp;&amp; typeof obj[0] != 'object') &amp;&amp; obj != null) &#123; obj = isArrayLike(obj) ? obj : _.values(obj); for (var i = 0, length = obj.length; i &lt; length; i++) &#123; value = obj[i]; // 如果目前的值value大于最大值result, 且不等于null或undefined // 则将value赋值给result if (value != null &amp;&amp; value &gt; result) &#123; result = value; &#125; &#125; // 如果存在interatee, 则每次用回调函数处理元素以得到计算值。 // 比较计算值, 获取最大值时候的元素, 并在最后一步返回 &#125; else &#123; iteratee = cb(iteratee, context); _.each(obj, function(v, index, list) &#123; computed = iteratee(v, index, list); // 如果计算值大于最大计算值 或者目前计算值和最大值result都为无限小 // 则将最大值result设置为目前值v, 最大计算值lastComputed设置为目前计算值computed // 这里判断computed === -Infinity &amp;&amp; result === -Infinity是为了防止只有一个元素的数组错误的返回-Infinity if (computed &gt; lastComputed || computed === -Infinity &amp;&amp; result === -Infinity) &#123; result = v; lastComputed = computed; &#125; &#125;); &#125; // 当obj为空时候将默认返回初始值, -Infinity return result;&#125;; 判断 != null``` 的原因是防止null与数值比较发生隐式转换产生未知的结果, 如:12```javascript null &gt; -1 // true 因为null被隐式转换为数字0 具体比较规则有： 如果两个操作数都是数值，则执行数值比较。 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。 如果一个操作数是对象，则调用这个对象的 ```valueOf()```方法，则调用 ```toString()```方法，并用得到的结果根据前面的规则执行比12345678910111213141516171819202122232425262728* 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。#### _.min```javascript // 返回集合中最小的元素 (如果存在iteratee, 则其大小的评估将基于iteratee计算). _.min = function(obj, iteratee, context) &#123; var result = Infinity, lastComputed = Infinity, value, computed; if (iteratee == null || (typeof iteratee == &apos;number&apos; &amp;&amp; typeof obj[0] != &apos;object&apos;) &amp;&amp; obj != null) &#123; obj = isArrayLike(obj) ? obj : _.values(obj); for (var i = 0, length = obj.length; i &lt; length; i++) &#123; value = obj[i]; if (value != null &amp;&amp; value &lt; result) &#123; result = value; &#125; &#125; &#125; else &#123; iteratee = cb(iteratee, context); _.each(obj, function(v, index, list) &#123; computed = iteratee(v, index, list); if (computed &lt; lastComputed || computed === Infinity &amp;&amp; result === Infinity) &#123; result = v; lastComputed = computed; &#125; &#125;); &#125; return result; &#125;; 思路类似_.max _.sample1234567891011121314151617181920212223// 一个随机打乱的洗牌算法_.sample = function(obj, n, guard) &#123; // 如果n为null、undefined 或者 guard值为真, 则返回obj中的一个随机元素 if (n == null || guard) &#123; if (!isArrayLike(obj)) obj = _.values(obj); return obj[_.random(obj.length - 1)]; &#125; // 如果是类数组则直接克隆一个副本, 如果不是则取其值为数组 var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj); var length = getLength(sample); // Math.min(n, length) 设定给出的n最大为length, Math.max(n, 0) 设定n最小为0 n = Math.max(Math.min(n, length), 0); var last = length - 1; for (var index = 0; index &lt; n; index++) &#123; // 随机算法, 每次将index位的元素与后面随机位的元素交换 var rand = _.random(index, last); var temp = sample[index]; sample[index] = sample[rand]; sample[rand] = temp; &#125; // 截取给定的长度 return sample.slice(0, n);&#125;; 利用Fisher-Yates shuffle算法进行随机取样。 _.shuffle1234// 利用之前的_.sample方法打乱一个集合的内部排序_.shuffle = function(obj) &#123; return _.sample(obj, Infinity);&#125;; _.sortBy1234567891011121314151617181920212223242526// 依据iteratee, 对集合中的每个元素进行处理后进行排序_.sortBy = function(obj, iteratee, context) &#123; var index = 0; iteratee = cb(iteratee, context); // 返回一个新对象, 包含value, index, criteria三个属性, 后续会用这三属性进行排序 // 并通过_.pluck将排序后集合中的每个对象的value值提取出来组成新数组。 return _.pluck(_.map(obj, function(value, key, list) &#123; return &#123; value: value, index: index++, criteria: iteratee(value, key, list) &#125;; // 利用原生的Array.prototype.sort 进行排序 &#125;).sort(function(left, right) &#123; var a = left.criteria; var b = right.criteria; // 当a不等于b时, 可直接进行返回 if (a !== b) &#123; // 比较a, b是否是void 0, 以将undefined排序至集合末尾 if (a &gt; b || a === void 0) return 1; if (a &lt; b || b === void 0) return -1; &#125; // 如果a与b相等, 则比较其索引 return left.index - right.index; &#125;), 'value');&#125;; group1234567891011121314151617// 为后续的_.groupBy方法而预先定义的一个内部私有方法// behavior用来处理最终需要返回的结果, partition用来判定是否简单分割var group = function(behavior, partition) &#123; return function(obj, iteratee, context) &#123; // 如果partition为真值则做简单分割, 以二维数组为容器, 否则以空对象为容器 var result = partition ? [[], []] : &#123;&#125;; iteratee = cb(iteratee, context); _.each(obj, function(value, index) &#123; // 获取相应的键值 var key = iteratee(value, index, obj); // 用behavior处理result behavior(result, value, key); &#125;); // 返回最终结果 return result; &#125;;&#125;; _.groupBy1234567// 利用之前的group方法进行分组_.groupBy = group(function(result, value, key) &#123; // 如果已经存在此键值数组, 则push进去 if (_.has(result, key)) result[key].push(value); // 否则为此键值新建一个仅包含目前value的数组 else result[key] = [value];&#125;); _.indexBy12345// 以传入的集合为样本, 生成相应的 `key-value` 对象// 如果有同key的键值对, 则后者会覆盖前者_.indexBy = group(function(result, value, key) &#123; result[key] = value;&#125;); _.countBy1234// 返回集合中的对象的数量的计数。类似groupBy，但是不是返回列表的值，而是返回在该组中值的数目。_.countBy = group(function(result, value, key) &#123; if (_.has(result, key)) result[key]++; else result[key] = 1;&#125;); _.toArray12345678910111213141516171819202122// 根据utf-16对任意字符进行处理, 来创建数组// [^\\ud800-\\udfff] 表示不包含代理对代码点的所有字符// [\\ud800-\\udbff][\\udc00-\\udfff] 表示合法的代理对的所有字符// [\\ud800-\\udfff] 表示代理对的代码点（本身不是合法的Unicode字符）// 来自[知乎](https://www.zhihu.com/question/38324041)var reStrSymbol = /[^\\ud800-\\udfff]|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff]/g;// 将传入的obj转化为数组_.toArray = function(obj) &#123; // 如果obj为假值, 则直接返回空数组 if (!obj) return []; // 如果obj本身就是数组, 则返回其拷贝 if (_.isArray(obj)) return slice.call(obj); // 如果obj是字符串, 则按字符分割成数组 if (_.isString(obj)) &#123; // 保持代理对字符被解析为一个字符 return obj.match(reStrSymbol); &#125; // 如果是类数组, 则返回其数组形式的映射 if (isArrayLike(obj)) return _.map(obj, _.identity); // 其他情况返回其values数组 return _.values(obj);&#125;; _.size12345// 返回对象的元素数量_.size = function(obj) &#123; if (obj == null) return 0; return isArrayLike(obj) ? obj.length : _.keys(obj).length;&#125;; _.partition1234// 将集合分割为俩部分, 前者通过predicate为真值, 后者为假值_.partition = group(function(result, value, pass) &#123; result[pass ? 0 : 1].push(value);&#125;, true); 数组方法_.initial1234// 返回数组中除了最后n个以外的其他所有元素。_.initial = function(array, n, guard) &#123; return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));&#125;; 个人认为initial也可以这样重写123_.initial = function(array, n, guard) &#123; return slice.call(array, 0, -(Math.max(n == null || guard ? 1 : n, 0)));&#125;; _.first123456789// 返回数组中的前n个元素_.first = _.head = _.take = function(array, n, guard) &#123; // 如果数组不存在, 或者数组的长度小于1, 则返回undefined if (array == null || array.length &lt; 1) return void 0; // 如果n不存在或者guard为真值, 则返回数组的第一个元素 if (n == null || guard) return array[0]; // 以上情况都不是就利用_.initial返回数组的前n个元素 return _.initial(array, array.length - n);&#125;; _.rest1234// 返回数组中除了前面n个元素以外的所有元素_.rest = _.tail = _.drop = function(array, n, guard) &#123; return slice.call(array, n == null || guard ? 1 : n);&#125;; _.last123456// 返回数组中最后的n个元素_.last = function(array, n, guard) &#123; if (array == null || array.length &lt; 1) return void 0; if (n == null || guard) return array[array.length - 1]; return _.rest(array, Math.max(0, array.length - n));&#125;; _.compact1234// 去除数组中的所有假值元素_.compact = function(array) &#123; return _.filter(array, Boolean);&#125;; _.flatten123456789101112131415161718192021222324252627282930313233// 递归实现的内部`flatten`函数var flatten = function(input, shallow, strict, output) &#123; // 通过output来保存结果 output = output || []; // 用idx追踪目前的索引位, 以便后续赋值, 这样比直接push性能要好 var idx = output.length; // 遍历input数组 for (var i = 0, length = getLength(input); i &lt; length; i++) &#123; var value = input[i]; // 如果目前的value是类数组, 并且是数组或arguments, 则根据shallow参数进行展平 if (isArrayLike(value) &amp;&amp; (_.isArray(value) || _.isArguments(value))) &#123; // 如果shallow为真值, 则仅展平一层 if (shallow) &#123; var j = 0, len = value.length; while (j &lt; len) output[idx++] = value[j++]; // 其他情况递归展平 &#125; else &#123; flatten(value, shallow, strict, output); idx = output.length; &#125; // 其他情况, 且非严格情况, 则添加到output的末尾 // 严格模式下就跳过 &#125; else if (!strict) &#123; output[idx++] = value; &#125; &#125; return output;&#125;;// 展平一个数组, 可以通过传入shallow来决定是否只展平一层, 还是递归展平全部_.flatten = function(array, shallow) &#123; return flatten(array, shallow, false);&#125;; _.difference123456789// 返回仅在第一个数组中出现的元素_.difference = restArgs(function(array, rest) &#123; // 注意这里第三个参数传入的是true, 代表其为严格模式, 如果rest中的直接子元素是非类数组会被忽略 rest = flatten(rest, true, true); return _.filter(array, function(value)&#123; // 过滤掉同时出现在其他数组中的元素 return !_.contains(rest, value); &#125;);&#125;); _.without1234567// 返回仅在第一个数组中出现的元素, 与_.difference不同的是otherArrays中的直接子元素// 为非类数组时不会被忽略, 因为经restArgs再包装, // 所有array后的参数都被并入了otherArrays,// otherArrays作为单一数组又在_.difference中被再包装_.without = restArgs(function(array, otherArrays) &#123; return _.difference(array, otherArrays);&#125;); _.uniq12345678910111213141516171819202122232425262728293031323334353637// 数组去重, 如果数组已经排序, 可以传入isSorted参数来使用更快的算法_.uniq = _.unique = function(array, isSorted, iteratee, context) &#123; // 通过这一步, 当数组没有排序或不想使用更快算法时, 可以省缺isSorted if (!_.isBoolean(isSorted)) &#123; context = iteratee; iteratee = isSorted; isSorted = false; &#125; if (iteratee != null) iteratee = cb(iteratee, context); var result = []; // 当数组array已被排序时, 用来保存上一次的结果, // 当其未被排序时候, 用来保存之前计算值 var seen = []; // 遍历数组 for (var i = 0, length = getLength(array); i &lt; length; i++) &#123; var value = array[i], // 如果iteratee存在, 则求其计算值, 否则用原值作为计算值 computed = iteratee ? iteratee(value, i, array) : value; // 如果数组已经排序了, 则直接比较是否与上一值相同, 不相同就push // 当索引为第一位时也push if (isSorted) &#123; if (!i || seen !== computed) result.push(value); seen = computed; // 如果iteratee存在, 则查询其计算值数组, // 如果目前的计算值不与计算值数组中有重复则push &#125; else if (iteratee) &#123; if (!_.contains(seen, computed)) &#123; seen.push(computed); result.push(value); &#125; // 如果iteratee不存在, 则直接在结果数组中查找目前元素是否已存在 &#125; else if (!_.contains(result, value)) &#123; result.push(value); &#125; &#125; return result;&#125;; _.union1234// 返回传入数组的并集, 并去重_.union = restArgs(function(arrays) &#123; return _.uniq(flatten(arrays, true, true));&#125;); _.intersection123456789101112131415// 返回传入数组的交集(即在所有数组中都出现过)_.intersection = function(array) &#123; var result = []; var argsLength = arguments.length; for (var i = 0, length = getLength(array); i &lt; length; i++) &#123; var item = array[i]; if (_.contains(result, item)) continue; var j; for (j = 1; j &lt; argsLength; j++) &#123; if (!_.contains(arguments[j], item)) break; &#125; if (j === argsLength) result.push(item); &#125; return result;&#125;; 比较好奇的是这里为什么不能像之前一样用restArgs, 而要使用arguments?当然, 如果用restArgs, 可以这样重写1234567891011121314_.intersection = restArgs(function(array, args) &#123; var result = []; var argsLength = args.length; for (var i = 0, length = getLength(array); i &lt; length; i++) &#123; var item = array[i]; if (_.contains(result, item)) continue; var j; for (j = 0; j &lt; argsLength; j++) &#123; if (!_.contains(arguments[j], item)) break; &#125; if (j === argsLength) result.push(item); &#125; return result;&#125;); _.unzip123456789101112// 接受一个二维数组, 并将其子数组的元素以索引值打包_.unzip = function(array) &#123; // 获取数组中长度最大的子数组的长度 var length = array &amp;&amp; _.max(array, getLength).length || 0; // 预先定义一定长度的稀疏数组, 相比与新建空数组后push, 性能要更好 var result = Array(length); // 遍历取值 for (var index = 0; index &lt; length; index++) &#123; result[index] = _.pluck(array, index); &#125; return result;&#125;; _.zip1234// 利用restArgs 与 _.unzip实现的zip函数// 除了传入的参数不是唯一的一个二维数组, 而是多个参数,// 其他效果相同_.zip = restArgs(_.unzip); _.object12345678910111213141516// 将列表转化为对象, 传递任何一个单独[key, value]对的列表，// 或者一个键的列表和一个值的列表。 // 如果存在重复键，最后一个值将被返回。_.object = function(list, values) &#123; var result = &#123;&#125;; for (var i = 0, length = getLength(list); i &lt; length; i++) &#123; // 如果values存在, 则代表传入的是一个key列表, 和一个value列表 if (values) &#123; result[list[i]] = values[i]; // 如果values不存在, 则代表传入的是一个单独的[key, value]对的列表 &#125; else &#123; result[list[i][0]] = list[i][1]; &#125; &#125; return result;&#125;; _.findIndex 与 _.findLastIndex1234567891011121314151617// 为了创建findIndex和findLastIndex的内部私有函数, 封装了共有逻辑var createPredicateIndexFinder = function(dir) &#123; return function(array, predicate, context) &#123; predicate = cb(predicate, context); var length = getLength(array); var index = dir &gt; 0 ? 0 : length - 1; for (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123; if (predicate(array[index], index, array)) return index; &#125; return -1; &#125;;&#125;;// 返回匹配predicate的第一个值的索引_.findIndex = createPredicateIndexFinder(1);// 返回匹配predicate的最后一个值的索引_.findLastIndex = createPredicateIndexFinder(-1); _.sortedIndex1234567891011// 利用二分查找法去查询能够插入元素且保持其排序不变的位置_.sortedIndex = function(array, obj, iteratee, context) &#123; iteratee = cb(iteratee, context, 1); var value = iteratee(obj); var low = 0, high = getLength(array); while (low &lt; high) &#123; var mid = Math.floor((low + high) / 2); if (iteratee(array[mid]) &lt; value) low = mid + 1; else high = mid; &#125; return low;&#125;; _.indexOf 与 _.lastIndexOf12345678910111213141516171819202122232425262728293031323334// 为了创建indexOf和lastIndexOf的内部私有函数, 封装了共有逻辑var createIndexFinder = function(dir, predicateFind, sortedIndex) &#123; return function(array, item, idx) &#123; var i = 0, length = getLength(array); if (typeof idx == 'number') &#123; if (dir &gt; 0) &#123; // 如果传入的idx为负, 则会取其倒数第idx绝对值的位置开始查询 i = idx &gt;= 0 ? idx : Math.max(idx + length, i); &#125; else &#123; length = idx &gt;= 0 ? Math.min(idx + 1, length) : idx + length + 1; &#125; // 如果sortedIndex存在, idx存在且不为数字, length存在, // 则用sortedIndex方法去查找索引 &#125; else if (sortedIndex &amp;&amp; idx &amp;&amp; length) &#123; idx = sortedIndex(array, item); return array[idx] === item ? idx : -1; &#125; // 如果item不等于自身, 则代表其为NaN, 需要用特定的方法去比较 if (item !== item) &#123; idx = predicateFind(slice.call(array, i, length), _.isNaN); return idx &gt;= 0 ? idx + i : -1; &#125; // 遍历查找 for (idx = dir &gt; 0 ? i : length - 1; idx &gt;= 0 &amp;&amp; idx &lt; length; idx += dir) &#123; if (array[idx] === item) return idx; &#125; return -1; &#125;;&#125;;// 返回数组中特定元素第一次出现的索引, 如果一次都没有出现则返回-1, // 如果数组已经排序, 可以传入isSorted为true, 使其用效率更高的二分查找算法_.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);_.lastIndexOf = createIndexFinder(-1, _.findLastIndex); _.range123456789101112131415161718192021// 根据传入的参数生成数组, 类似等差数列_.range = function(start, stop, step) &#123; // 如果stop不存在, 即另传入的第一个参数为stop if (stop == null) &#123; stop = start || 0; start = 0; &#125; // 如果步数step不存在, 则根据其start与stop的大小比较来判断其是1或者-1 if (!step) &#123; step = stop &lt; start ? -1 : 1; &#125; var length = Math.max(Math.ceil((stop - start) / step), 0); var range = Array(length); for (var idx = 0; idx &lt; length; idx++, start += step) &#123; range[idx] = start; &#125; return range;&#125;; _.chunk123456789101112// 将数组array分成多个小数组, 每个小数组包含count个元素// of initial array._.chunk = function(array, count) &#123; if (count == null || count &lt; 1) return []; var result = []; var i = 0, length = array.length; while (i &lt; length) &#123; result.push(slice.call(array, i, i += count)); &#125; return result;&#125;;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yuyanggong.github.io/tags/JavaScript/"},{"name":"Underscore","slug":"Underscore","permalink":"https://yuyanggong.github.io/tags/Underscore/"},{"name":"源码分析","slug":"源码分析","permalink":"https://yuyanggong.github.io/tags/源码分析/"}]},{"title":"Underscore源码分析之整体结构","date":"2017-03-16T10:37:04.486Z","path":"2017/03/16/underscore源码解析之整体结构/","text":"库名: underscore 源码地址: https://github.com/jashkenas/underscore 源码版本: 1.8.3 分析内容: 整体结构 环境兼容1234567891011121314151617181920212223242526272829(function() &#123; // 通过IIFE避免变量全局污染 // 统一根对象，在`webWorker`中指向`self`, 在服务器(nodeJS)上指向`global`, // 在其他情况下指向this(在浏览器中, 因函数调用, this将指向window); var root = typeof self == 'object' &amp;&amp; self.self === self &amp;&amp; self || typeof global == 'object' &amp;&amp; global.global === global &amp;&amp; global || this; // 在nodeJS(或者其他支持commonJS的环境)中暴露Underscore对象, 且向后兼容其旧API。 // 如果不是nodeJS环境, 则把Underscore对象挂载在根对象root上。 // ('nodeType' 用来检测module和exports不是HTML元素 // 因HTML5中, 具有ID的HTML元素, 其引用会被直接挂载在全局的同名[id名]变量上) if (typeof exports != 'undefined' &amp;&amp; !exports.nodeType) &#123; if (typeof module != 'undefined' &amp;&amp; !module.nodeType &amp;&amp; module.exports) &#123; exports = module.exports = _; &#125; exports._ = _; &#125; else &#123; root._ = _; &#125; // 在支持AMD的环境中, 暴露Underscore对象 if (typeof define == 'function' &amp;&amp; define.amd) &#123; define('underscore', [], function() &#123; return _; &#125;); &#125; &#125;()); 对环境做了判断, 用root引用全局对象, 在相应的环境中指向相应的全局变量, 使表现一致。且支持CommonJS, AMD等模块化规范, 兼容了各种环境。 避免变量名’_’冲突123456789// 保留之前全局上挂载的'_'的值var previousUnderscore = root._;// 将之前全局上挂载的'_'的值, 重新赋值给'_', '_'不再指向Underscore// 此方法执行后返回this(当其调用者为Underscore的时候, 其this也就指向Underscore对象)_.noConflict = function() &#123; root._ = previousUnderscore; return this;&#125;; Underscore构造函数1234567// 创建Underscore的安全引用, 当不用new调用构造函数时, 也会正确的实例化// 创造出来的实例对象, 目前只有一个_wrapped属性, 指向之前传的参数objvar _ = function(obj) &#123;if (obj instanceof _) return obj;if (!(this instanceof _)) return new _(obj);this._wrapped = obj; &#125;; 创建原型链及其上方法的快速引用1234567891011121314// 将原型链赋值给变量, 有利于代码压缩var ArrayProto = Array.prototype, ObjProto = Object.prototype;var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;// 创建Array原型上的push,slice和Object原型上的toString,hasOwnProperty方法的快速引用。var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;// 创建 ES5 中的isArray, keys, create的原生函数的快速引用var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create; 将原型链或链上方法的引用给变量, 其好处有如下: 减少有利于代码压缩, 为生产环境中的代码量减重。 减少对象上属性的查询次数, 优化性能。 少打一些字(但考虑到这些都是私有方法及对象, 所以并不算)。 链式调用的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 // 一个挂载在Underscore上的方法, 用于创建可以链式调用的对象。 // 其以obj为参数, 创建一个Underscore实例, 并将实例上的_chain属性设置为true。 _.chain = function(obj) &#123; var instance = _(obj); instance._chain = true; return instance; &#125;; // 一个私有的辅助函数, 如果传入的实例已经经过_.chain处理了(即instance._chain为真) // 则返回再次的链式调用, 否则返回第二个参数obj var chainResult = function(instance, obj) &#123; return instance._chain ? _(obj).chain() : obj; &#125;; // 给Underscore对象添加自定义方法。 _.mixin = function(obj) &#123; // 遍历obj对象上方法, 在Underscore对象上创建同名方法, 连接引用。 _.each(_.functions(obj), function(name) &#123; var func = _[name] = obj[name]; // 在原型链上也创建同名方法, 此方法内部处理的对象是挂载在实例上的_wrapped对象 _.prototype[name] = function() &#123; // 将实例上的_wrapped对象, 以及传入的参数都保存进args数组 var args = [this._wrapped]; push.apply(args, arguments); // 调用私有方法chainResult, 传入实例作为第一参数 // 传入 经过Underscore对象上相关方法处理后的对象作为第二参数 return chainResult(this, func.apply(_, args)); &#125;; &#125;); return _; &#125;;// 将Underscore对象上所有的方法添加到其原型上。 _.mixin(_); // 将数组原型链中会改变原数组的方法添加到Underscore中。 _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) &#123; var method = ArrayProto[name]; // 同样也稍作修改添加到原型上。 _.prototype[name] = function() &#123; var obj = this._wrapped; method.apply(obj, arguments); if ((name === 'shift' || name === 'splice') &amp;&amp; obj.length === 0) delete obj[0]; return chainResult(this, obj); &#125;; &#125;); // 将数组原型链中不会改变原数组的方法添加到Underscore中。 // 与上面的差别主要是, 这里返回的都是新对象, 而上面是原本的对象 _.each(['concat', 'join', 'slice'], function(name) &#123; var method = ArrayProto[name]; _.prototype[name] = function() &#123; return chainResult(this, method.apply(this._wrapped, arguments)); &#125;; &#125;); // 获取链式调用的结果对象, 即this._wrapped _.prototype.value = function() &#123; return this._wrapped; &#125;; // 将原型链上的value方法的引用给原型链上的valueOf和toJSON // 以便JS引擎内部取值或者JSON字符串化时, 处理的对象是this._wrapped // 而不是实例对象 _.prototype.valueOf = _.prototype.toJSON = _.prototype.value; // 写原型链上的toString方法 // 以便JS引擎内部调用Underscore实例的toString方法(如instance + 'string')时, // 返回的是其this._wrapped的字符串形式 // 而不是实例的字符串形式 _.prototype.toString = function() &#123; return String(this._wrapped); &#125; 将Underscore构造函数作为对象的包装器，在实例化时接受一个对象为参数，并将此对象作为实例的_wrapped属性保存, 然后将Underscore的方法稍作修改放置在其原型上(修改主要是为了原型链上的方法操作的是_wrapped对象)，以便实例可以通过原型链来查询到相关方法并使用, 巧妙的实现了链式调用。内部也通过_chain属性来判断是否链式调用，如果是的话则返回包装后的对象(即Underscore实例,具有_wrapped和_chain属性及Underscore原型链)，否则直接返回源对象(非Underscore实例)。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yuyanggong.github.io/tags/JavaScript/"},{"name":"Underscore","slug":"Underscore","permalink":"https://yuyanggong.github.io/tags/Underscore/"},{"name":"源码分析","slug":"源码分析","permalink":"https://yuyanggong.github.io/tags/源码分析/"}]}]